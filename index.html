<!DOCTYPE html>

<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>NEON SLAPSHOT - Hockey FPS</title>

```
<!-- Mobile Optimizations -->
<link rel="manifest" href="manifest.json">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black">
<meta name="theme-color" content="#000000">
<link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='0.9em' font-size='90'>üèí</text></svg>">

<style>
    @import url('https://fonts.googleapis.com/css2?family=Bebas+Neue&display=swap');
    
    * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
        user-select: none;
        -webkit-tap-highlight-color: transparent;
    }
    
    body {
        font-family: 'Bebas Neue', sans-serif;
        background: #000;
        color: #fff;
        overflow: hidden;
        touch-action: none;
        position: relative;
    }
    
    #gameCanvas, #backgroundCanvas {
        position: absolute;
        top: 0;
        left: 0;
        cursor: crosshair;
    }
    
    #backgroundCanvas {
        z-index: 1;
    }
    
    #gameCanvas {
        z-index: 2;
    }
    
    .ui-overlay {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        padding: 1.25rem;
        pointer-events: none;
        z-index: 5;
    }
    
    .score-display {
        display: flex;
        justify-content: space-between;
        align-items: flex-start;
        font-size: 1.5rem;
        text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
    }
    
    .score-item {
        background: rgba(0, 0, 0, 0.7);
        padding: 0.625rem 1.25rem;
        border-radius: 5px;
        backdrop-filter: blur(10px);
    }
    
    .power-meter {
        position: absolute;
        bottom: 9.375rem;
        left: 50%;
        transform: translateX(-50%);
        width: min(300px, 80vw);
        height: 20px;
        border: 2px solid #fff;
        background: rgba(0, 0, 0, 0.5);
        overflow: hidden;
        border-radius: 10px;
    }
    
    .power-fill {
        height: 100%;
        width: 0%;
        background: linear-gradient(to right, #00ff00, #ffff00, #ff0000);
        transition: width 0.1s;
    }
    
    .shot-type {
        position: absolute;
        bottom: 11.25rem;
        left: 50%;
        transform: translateX(-50%);
        font-size: 1.125rem;
        color: #fff;
        text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
        background: rgba(0, 0, 0, 0.7);
        padding: 0.3125rem 0.9375rem;
        border-radius: 5px;
    }
    
    .controls {
        position: absolute;
        bottom: 13.75rem;
        left: 50%;
        transform: translateX(-50%);
        text-align: center;
        font-size: 0.875rem;
        color: #ccc;
        text-shadow: 1px 1px 2px #000;
    }
    
    .shot-selector {
        position: absolute;
        bottom: 1.875rem;
        left: 50%;
        transform: translateX(-50%);
        display: flex;
        gap: 0.625rem;
        pointer-events: all;
    }
    
    .shot-button {
        background: rgba(0, 0, 0, 0.7);
        border: 2px solid #666;
        color: #fff;
        padding: 0.9375rem 1.25rem;
        font-family: 'Bebas Neue', sans-serif;
        font-size: 1rem;
        cursor: pointer;
        transition: all 0.3s;
        border-radius: 5px;
        pointer-events: all;
    }
    
    .shot-button.active {
        background: #ff0000;
        border-color: #ff0000;
        transform: scale(1.1);
        box-shadow: 0 0 20px rgba(255,0,0,0.6);
    }
    
    .home-button {
        position: absolute;
        top: 1.25rem;
        right: 1.25rem;
        width: 3.125rem;
        height: 3.125rem;
        background: rgba(0, 0, 0, 0.7);
        border: 2px solid #fff;
        border-radius: 5px;
        cursor: pointer;
        display: none;
        align-items: center;
        justify-content: center;
        font-size: 1.5rem;
        pointer-events: all;
        z-index: 10;
        color: #fff;
    }
    
    .home-button:hover {
        background: rgba(255, 0, 0, 0.7);
        transform: scale(1.1);
    }
    
    .announcement {
        position: absolute;
        top: 30%;
        left: 50%;
        transform: translate(-50%, -50%);
        font-size: 4.5rem;
        font-weight: bold;
        color: #ff0000;
        text-shadow: 4px 4px 8px rgba(0,0,0,0.8);
        opacity: 0;
        pointer-events: none;
        z-index: 20;
        letter-spacing: 4px;
    }
    
    .announcement.show {
        animation: announce 1.5s ease-out;
    }
    
    @keyframes announce {
        0% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
        50% { opacity: 1; transform: translate(-50%, -50%) scale(1.2); }
        100% { opacity: 0; transform: translate(-50%, -50%) scale(1); }
    }
    
    #startScreen {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: linear-gradient(180deg, #1a1a2e, #0f0f1e);
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        z-index: 100;
    }
    
    #startScreen h1 {
        font-size: min(5.25rem, 15vw);
        color: #fff;
        text-shadow: 6px 6px 12px rgba(0,0,0,0.8);
        margin-bottom: 2.5rem;
        letter-spacing: 6px;
    }
    
    .difficulty-selector {
        display: flex;
        gap: 0.625rem;
        margin-bottom: 1.875rem;
        justify-content: center;
    }
    
    .difficulty-label {
        color: #ccc;
        margin-bottom: 1.25rem;
        font-size: 1.125rem;
    }
    
    .menu-buttons {
        display: flex;
        flex-direction: column;
        gap: 0.9375rem;
        margin-top: 1.25rem;
    }
    
    .menu-button {
        background: #ff0000;
        border: none;
        color: #fff;
        padding: 1.25rem 2.5rem;
        font-family: 'Bebas Neue', sans-serif;
        font-size: 1.5rem;
        cursor: pointer;
        transition: all 0.3s;
        letter-spacing: 2px;
        text-transform: uppercase;
        min-width: 250px;
    }
    
    .menu-button:hover {
        background: #ff3333;
        transform: scale(1.05);
        box-shadow: 0 8px 20px rgba(255,0,0,0.4);
    }
    
    .difficulty-button {
        background: #333;
        border: 2px solid #666;
        color: #fff;
        padding: 0.625rem 1.25rem;
        font-family: 'Bebas Neue', sans-serif;
        font-size: 1.125rem;
        cursor: pointer;
        transition: all 0.3s;
    }
    
    .difficulty-button.active {
        background: #ff0000;
        border-color: #ff0000;
    }
    
    .difficulty-button[data-difficulty="easy"] {
        border-color: #4CAF50;
    }
    
    .difficulty-button[data-difficulty="easy"].active {
        background: #4CAF50;
    }
    
    .difficulty-button[data-difficulty="medium"] {
        border-color: #FFC107;
    }
    
    .difficulty-button[data-difficulty="medium"].active {
        background: #FFC107;
    }
    
    .difficulty-button[data-difficulty="hard"] {
        border-color: #f44336;
    }
    
    .difficulty-button[data-difficulty="hard"].active {
        background: #f44336;
    }
    
    .rebound-alert {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        font-size: 2.25rem;
        color: #ffff00;
        text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
        opacity: 0;
        pointer-events: none;
    }
    
    .rebound-alert.show {
        animation: reboundPulse 1s ease-out;
    }
    
    @keyframes reboundPulse {
        0% { opacity: 0; transform: translate(-50%, -50%) scale(0.8); }
        50% { opacity: 1; transform: translate(-50%, -50%) scale(1.1); }
        100% { opacity: 0; transform: translate(-50%, -50%) scale(1); }
    }
    
    .crosshair {
        position: absolute;
        width: 40px;
        height: 40px;
        border: 2px solid #0ff;
        border-radius: 50%;
        opacity: 0.5;
        pointer-events: none;
        transform: translate(-50%, -50%);
        transition: all 0.1s;
        display: none;
        z-index: 15;
    }
    
    .crosshair::before,
    .crosshair::after {
        content: '';
        position: absolute;
        background: #0ff;
    }
    
    .crosshair::before {
        width: 2px;
        height: 20px;
        left: 50%;
        top: 50%;
        transform: translate(-50%, -50%);
    }
    
    .crosshair::after {
        width: 20px;
        height: 2px;
        left: 50%;
        top: 50%;
        transform: translate(-50%, -50%);
    }
    
    .crosshair.show {
        display: block;
    }
    
    .game-over-screen {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(0, 0, 0, 0.95);
        border: 3px solid #0ff;
        border-radius: 10px;
        padding: 2rem;
        text-align: center;
        display: none;
        z-index: 50;
        min-width: 300px;
    }
    
    .game-over-screen h2 {
        color: #ff0000;
        font-size: 2.5rem;
        margin-bottom: 1rem;
        text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
    }
    
    .stats-row {
        display: flex;
        justify-content: space-between;
        margin: 0.5rem 0;
        font-size: 1.25rem;
        color: #0ff;
    }
    
    .game-over-buttons {
        display: flex;
        gap: 1rem;
        margin-top: 1.5rem;
        justify-content: center;
    }
    
    .game-over-button {
        background: #ff0000;
        border: none;
        color: #fff;
        padding: 0.75rem 1.5rem;
        font-family: 'Bebas Neue', sans-serif;
        font-size: 1.25rem;
        cursor: pointer;
        transition: all 0.3s;
        border-radius: 5px;
    }
    
    .game-over-button:hover {
        background: #ff3333;
        transform: scale(1.05);
    }
    
    @media (max-width: 768px) {
        .score-item {
            font-size: 1.125rem;
            padding: 0.5rem 0.9375rem;
        }
        
        #startScreen h1 {
            font-size: 3rem;
        }
        
        .menu-button {
            font-size: 1.25rem;
            padding: 0.9375rem 1.875rem;
        }
        
        .announcement {
            font-size: 3rem;
        }
        
        .shot-button {
            font-size: 0.875rem;
            padding: 0.75rem 1rem;
        }
        
        .home-button {
            width: 2.8125rem;
            height: 2.8125rem;
            font-size: 1.25rem;
        }
    }
</style>
```

</head>
<body>
    <canvas id="backgroundCanvas"></canvas>
    <canvas id="gameCanvas"></canvas>

```
<div class="ui-overlay">
    <div class="score-display">
        <div class="score-item">SCORE: <span id="score">0</span></div>
        <div class="score-item">SHOTS: <span id="shots">0</span></div>
        <div class="score-item">SAVES: <span id="saves">0</span></div>
    </div>
</div>

<button class="home-button" id="homeBtn" title="Return to Menu" aria-label="Return to main menu">üè†</button>

<div class="announcement" id="announcement"></div>
<div class="rebound-alert" id="reboundAlert">REBOUND!</div>

<div class="shot-type" id="shotType">WRIST SHOT</div>
<div class="power-meter">
    <div class="power-fill" id="powerFill"></div>
</div>

<div class="controls">
    HOLD TO CHARGE ‚Ä¢ RELEASE TO SHOOT
</div>

<div class="shot-selector">
    <button class="shot-button active" id="wristBtn" aria-label="Select wrist shot">WRIST</button>
    <button class="shot-button" id="slapBtn" aria-label="Select slap shot">SLAP</button>
    <button class="shot-button" id="backhandBtn" aria-label="Select backhand shot">BACKHAND</button>
</div>

<div class="crosshair" id="crosshair"></div>

<div class="game-over-screen" id="gameOverScreen">
    <h2>GAME OVER!</h2>
    <div class="stats-row">
        <span>Final Score:</span>
        <span id="finalScore">0</span>
    </div>
    <div class="stats-row">
        <span>Accuracy:</span>
        <span id="finalAccuracy">0%</span>
    </div>
    <div class="stats-row">
        <span>Goals:</span>
        <span id="finalGoals">0/0</span>
    </div>
    <div class="game-over-buttons">
        <button class="game-over-button" onclick="playAgain()">PLAY AGAIN</button>
        <button class="game-over-button" onclick="returnToMenu()">MENU</button>
    </div>
</div>

<div id="startScreen">
    <h1>HOCKEY SHOOTOUT</h1>
    <div class="difficulty-label">SELECT DIFFICULTY</div>
    <div class="difficulty-selector">
        <button class="difficulty-button" id="easyBtn" data-difficulty="easy" aria-label="Easy difficulty">EASY</button>
        <button class="difficulty-button active" id="mediumBtn" data-difficulty="medium" aria-label="Medium difficulty">MEDIUM</button>
        <button class="difficulty-button" id="hardBtn" data-difficulty="hard" aria-label="Hard difficulty">HARD</button>
    </div>
    <div class="menu-buttons">
        <button class="menu-button" id="classicBtn" aria-label="Classic mode - 5 shots">CLASSIC MODE</button>
        <button class="menu-button" id="timeBtn" aria-label="Time attack mode - 60 seconds">TIME ATTACK</button>
        <button class="menu-button" id="suddenBtn" aria-label="Sudden death mode">SUDDEN DEATH</button>
        <button class="menu-button" id="practiceBtn" aria-label="Practice mode - no goalie">PRACTICE MODE</button>
    </div>
</div>

<script>
    // Get canvases
    const bgCanvas = document.getElementById('backgroundCanvas');
    const bgCtx = bgCanvas.getContext('2d');
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    
    // Cache DOM elements
    const scoreEl = document.getElementById('score');
    const shotsEl = document.getElementById('shots');
    const savesEl = document.getElementById('saves');
    const shotTypeEl = document.getElementById('shotType');
    const powerFillEl = document.getElementById('powerFill');
    const crosshairEl = document.getElementById('crosshair');
    const announcementEl = document.getElementById('announcement');
    const reboundAlertEl = document.getElementById('reboundAlert');
    const startScreenEl = document.getElementById('startScreen');
    const homeBtnEl = document.getElementById('homeBtn');
    const gameOverScreenEl = document.getElementById('gameOverScreen');
    
    // Check for haptic support once
    const canVibrate = 'vibrate' in navigator;
    
    // Game state
    let gameMode = 'classic';
    let gameActive = false;
    let gamePaused = false;
    let score = 0;
    let shots = 0;
    let saves = 0;
    let shotPower = 0;
    let isCharging = false;
    let mouseX = 0;
    let mouseY = 0;
    let shotType = 'wrist';
    let difficulty = 'medium';
    let lastTime = 0;
    let deltaTime = 0;
    
    // 3D perspective constants
    const PERSPECTIVE = 800;
    const NET_DISTANCE = 400;
    
    // Object pools
    const particlePool = [];
    const MAX_PARTICLES = 100;
    
    // Initialize particle pool
    for (let i = 0; i < MAX_PARTICLES; i++) {
        particlePool.push({
            active: false,
            x: 0, y: 0, z: 0,
            vx: 0, vy: 0, vz: 0,
            life: 0, size: 0, color: null
        });
    }
    
    function getParticle() {
        for (let p of particlePool) {
            if (!p.active) {
                p.active = true;
                return p;
            }
        }
        return null;
    }
    
    // Game objects
    let pucks = [];
    let goalie = {
        x: 0,
        y: 0,
        z: NET_DISTANCE,
        targetX: 0,
        targetY: -20,
        vx: 0,
        vy: 0,
        stance: 'ready',
        saveAnimation: 0,
        speed: 0.1,
        prediction: 0.7,
        stanceTimer: 0
    };
    
    let particles = [];
    let rebounds = [];
    let backgroundRendered = false;
    
    // Canvas setup
    function resizeCanvas() {
        bgCanvas.width = canvas.width = window.innerWidth;
        bgCanvas.height = canvas.height = window.innerHeight;
        backgroundRendered = false; // Re-render background on resize
    }
    
    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();
    
    // Event listeners using Pointer Events API
    canvas.addEventListener('pointerdown', startCharge);
    canvas.addEventListener('pointerup', shoot);
    canvas.addEventListener('pointermove', updateAim);
    
    // Button event listeners
    document.getElementById('wristBtn').addEventListener('click', () => selectShot('wrist'));
    document.getElementById('slapBtn').addEventListener('click', () => selectShot('slap'));
    document.getElementById('backhandBtn').addEventListener('click', () => selectShot('backhand'));
    
    document.getElementById('easyBtn').addEventListener('click', () => setDifficulty('easy'));
    document.getElementById('mediumBtn').addEventListener('click', () => setDifficulty('medium'));
    document.getElementById('hardBtn').addEventListener('click', () => setDifficulty('hard'));
    
    document.getElementById('classicBtn').addEventListener('click', () => startGame('classic'));
    document.getElementById('timeBtn').addEventListener('click', () => startGame('timeattack'));
    document.getElementById('suddenBtn').addEventListener('click', () => startGame('sudden'));
    document.getElementById('practiceBtn').addEventListener('click', () => startGame('practice'));
    
    homeBtnEl.addEventListener('click', returnToMenu);
    
    function selectShot(type) {
        shotType = type;
        shotTypeEl.textContent = type.toUpperCase() + ' SHOT';
        
        // Update button states
        document.querySelectorAll('.shot-button').forEach(btn => btn.classList.remove('active'));
        document.getElementById(type + 'Btn').classList.add('active');
        
        if (canVibrate) navigator.vibrate(10);
    }
    
    function setDifficulty(level) {
        difficulty = level;
        
        // Update goalie based on difficulty
        switch(level) {
            case 'easy':
                goalie.speed = 0.05;
                goalie.prediction = 0.5;
                break;
            case 'medium':
                goalie.speed = 0.1;
                goalie.prediction = 0.7;
                break;
            case 'hard':
                goalie.speed = 0.15;
                goalie.prediction = 0.9;
                break;
        }
        
        // Update button states
        document.querySelectorAll('.difficulty-button').forEach(btn => btn.classList.remove('active'));
        document.getElementById(level + 'Btn').classList.add('active');
    }
    
    function startCharge(e) {
        if (!gameActive || isCharging) return;
        isCharging = true;
        shotPower = 0;
    }
    
    function updateAim(e) {
        mouseX = e.clientX;
        mouseY = e.clientY;
        
        // Update crosshair position
        if (gameActive) {
            crosshairEl.classList.add('show');
            crosshairEl.style.left = mouseX + 'px';
            crosshairEl.style.top = mouseY + 'px';
        } else {
            crosshairEl.classList.remove('show');
        }
        
        // Update goalie prediction
        if (gameActive && !isCharging) {
            const aimX = (mouseX - canvas.width / 2) / canvas.width * 300;
            const aimY = (mouseY - canvas.height / 2) / canvas.height * 150;
            goalie.targetX = aimX * goalie.prediction;
            goalie.targetY = Math.max(-75, Math.min(30, aimY * 0.5));
        }
    }
    
    function shoot(e) {
        if (!gameActive || !isCharging) return;
        
        isCharging = false;
        shots++;
        updateUI();
        
        // Calculate shot properties based on type
        let velocity, accuracy, elevation;
        
        switch(shotType) {
            case 'slap':
                velocity = 25 + shotPower * 20;
                accuracy = 0.7 - shotPower * 0.2;
                elevation = 0.1 + Math.random() * 0.2;
                break;
            case 'backhand':
                velocity = 15 + shotPower * 10;
                accuracy = 0.85;
                elevation = 0.05 + Math.random() * 0.15;
                break;
            default: // wrist shot
                velocity = 20 + shotPower * 15;
                accuracy = 0.9 - shotPower * 0.1;
                elevation = 0.05 + Math.random() * 0.25;
        }
        
        // Create puck
        const aimX = (mouseX - canvas.width / 2) / canvas.width;
        const aimY = (canvas.height / 2 - mouseY) / canvas.height;
        
        const puck = {
            x: 0,
            y: 0,
            z: 0,
            vx: aimX * velocity * accuracy + (Math.random() - 0.5) * (1 - accuracy) * 10,
            vy: -elevation * velocity * 0.5,
            vz: velocity,
            size: 8,
            rotation: 0,
            rotationSpeed: Math.random() * 0.3 + 0.1,
            trail: []
        };
        
        pucks.push(puck);
        
        // Create ice spray particles using object pool
        for (let i = 0; i < 20; i++) {
            const particle = getParticle();
            if (particle) {
                particle.x = 0;
                particle.y = 0;
                particle.z = 0;
                particle.vx = (Math.random() - 0.5) * 5;
                particle.vy = -Math.random() * 3;
                particle.vz = Math.random() * 2;
                particle.life = 1;
                particle.size = Math.random() * 3 + 1;
                particle.color = null;
            }
        }
        
        if (canVibrate) navigator.vibrate(25);
        
        shotPower = 0;
        powerFillEl.style.width = '0%';
        
        // Update goalie stance based on shot
        if (puck.vy < -10) {
            goalie.stance = 'glove';
        } else if (puck.vy > -5) {
            goalie.stance = 'butterfly';
        } else {
            goalie.stance = 'blocker';
        }
        goalie.stanceTimer = 0;
    }
    
    function startGame(mode) {
        gameMode = mode;
        gameActive = true;
        score = 0;
        shots = 0;
        saves = 0;
        pucks = [];
        rebounds = [];
        
        // Reset particles
        particlePool.forEach(p => p.active = false);
        
        // Hide practice mode goalie
        if (mode === 'practice') {
            goalie.x = 1000;
        } else {
            goalie.x = 0;
        }
        
        startScreenEl.style.display = 'none';
        homeBtnEl.style.display = 'flex';
        gameOverScreenEl.style.display = 'none';
        updateUI();
        lastTime = performance.now();
        gameLoop(lastTime);
    }
    
    function project3D(x, y, z) {
        const scale = PERSPECTIVE / (PERSPECTIVE + z);
        return {
            x: canvas.width / 2 + x * scale,
            y: canvas.height / 2 + y * scale,
            scale: scale
        };
    }
    
    function updateGoalie(dt) {
        if (gameMode === 'practice') return;
        
        // Physics-based movement with delta time
        const dx = goalie.targetX - goalie.x;
        const dy = goalie.targetY - goalie.y;
        
        goalie.vx += dx * goalie.speed * 60 * dt;
        goalie.vy += dy * goalie.speed * 60 * dt;
        goalie.vx *= Math.pow(0.9, 60 * dt);
        goalie.vy *= Math.pow(0.9, 60 * dt);
        
        goalie.x += goalie.vx * dt * 60;
        goalie.y += goalie.vy * dt * 60;
        
        // Update save animation
        if (goalie.saveAnimation > 0) {
            goalie.saveAnimation -= 3 * dt;
        }
        
        // Return to ready stance after shot
        if (goalie.stanceTimer > 0) {
            goalie.stanceTimer -= 60 * dt;
            if (goalie.stanceTimer <= 0) {
                goalie.stance = 'ready';
            }
        }
        
        // If no pucks in play and goalie is not ready, start timer to stand up
        if (pucks.length === 0 && goalie.stance !== 'ready' && goalie.stanceTimer === 0) {
            goalie.stanceTimer = 30;
        }
    }
    
    function updatePucks(dt) {
        for (let i = pucks.length - 1; i >= 0; i--) {
            const puck = pucks[i];
            
            // Update trail
            if (puck.z < NET_DISTANCE) {
                puck.trail.push({ x: puck.x, y: puck.y, z: puck.z });
                if (puck.trail.length > 15) {
                    puck.trail.shift();
                }
            }
            
            // Physics update with delta time
            puck.x += puck.vx * dt * 60;
            puck.y += puck.vy * dt * 60;
            puck.z += puck.vz * dt * 60;
            
            // Gravity
            puck.vy += 18 * dt;
            
            // Ice friction
            puck.vx *= Math.pow(0.99, 60 * dt);
            puck.vz *= Math.pow(0.99, 60 * dt);
            
            // Rotation
            puck.rotation += puck.rotationSpeed * dt * 60;
            
            // Check for goal, save, or miss
            if (puck.z >= NET_DISTANCE) {
                const netWidth = 300;
                const netHeight = 150;
                const netTop = -90;
                
                const inNet = Math.abs(puck.x) < netWidth / 2 && 
                             puck.y > netTop && puck.y < netTop + netHeight;
                
                // Check goalie collision
                const goalieWidth = 90;
                const goalieHeight = 120;
                const hitGoalie = gameMode !== 'practice' &&
                                Math.abs(puck.x - goalie.x) < goalieWidth / 2 &&
                                Math.abs(puck.y - goalie.y) < goalieHeight / 2;
                
                if (hitGoalie) {
                    handleSave(puck, i);
                } else if (inNet) {
                    handleGoal(puck, i);
                } else {
                    // Hit post or miss
                    if (Math.abs(puck.x) < netWidth / 2 + 10 && 
                        puck.y > netTop - 10 && puck.y < netTop + netHeight + 10) {
                        handlePost(puck, i);
                    } else {
                        handleMiss(puck, i);
                    }
                }
            }
            
            // Remove if too far
            if (puck.z > NET_DISTANCE + 200 || puck.y > 200) {
                pucks.splice(i, 1);
            }
        }
        
        // Update rebounds
        for (let i = rebounds.length - 1; i >= 0; i--) {
            const rebound = rebounds[i];
            rebound.x += rebound.vx * dt * 60;
            rebound.y += rebound.vy * dt * 60;
            rebound.z += rebound.vz * dt * 60;
            rebound.vy += 30 * dt;
            
            if (rebound.y > 100 || rebound.z > NET_DISTANCE + 100) {
                rebounds.splice(i, 1);
            }
        }
    }
    
    function handleSave(puck, index) {
        saves++;
        goalie.saveAnimation = 1;
        showAnnouncement('SAVE!');
        
        if (canVibrate) navigator.vibrate([50, 50, 50]);
        
        // Create rebound
        const rebound = {
            x: puck.x,
            y: puck.y,
            z: puck.z,
            vx: -puck.vx * 0.5 + (Math.random() - 0.5) * 10,
            vy: -5,
            vz: -puck.vz * 0.3,
            size: puck.size
        };
        rebounds.push(rebound);
        
        reboundAlertEl.classList.add('show');
        setTimeout(() => reboundAlertEl.classList.remove('show'), 1000);
        
        pucks.splice(index, 1);
        updateUI();
        
        // Check game over
        if (gameMode === 'sudden' && saves > 0) {
            endGame();
        }
    }
    
    function handleGoal(puck, index) {
        score += 100;
        showAnnouncement('GOAL!!!');
        
        if (canVibrate) navigator.vibrate([100, 50, 100]);
        
        // Bonus for location
        if (puck.y < -60) {
            score += 50;
            setTimeout(() => showAnnouncement('TOP SHELF!'), 500);
        } else if (puck.y > 30) {
            score += 30;
            setTimeout(() => showAnnouncement('FIVE HOLE!'), 500);
        }
        
        // Goal celebration particles
        for (let i = 0; i < 50; i++) {
            const particle = getParticle();
            if (particle) {
                particle.x = puck.x;
                particle.y = puck.y;
                particle.z = NET_DISTANCE;
                particle.vx = (Math.random() - 0.5) * 20;
                particle.vy = (Math.random() - 0.5) * 20;
                particle.vz = (Math.random() - 0.5) * 10;
                particle.life = 1;
                particle.size = Math.random() * 5 + 2;
                particle.color = `hsl(${Math.random() * 360}, 100%, 50%)`;
            }
        }
        
        pucks.splice(index, 1);
        updateUI();
    }
    
    function handlePost(puck, index) {
        showAnnouncement('POST!');
        puck.vx *= -0.8;
        puck.vz *= 0.5;
        
        if (canVibrate) navigator.vibrate(50);
        
        for (let i = 0; i < 10; i++) {
            const particle = getParticle();
            if (particle) {
                particle.x = puck.x;
                particle.y = puck.y;
                particle.z = puck.z;
                particle.vx = (Math.random() - 0.5) * 10;
                particle.vy = -Math.random() * 5;
                particle.vz = -Math.random() * 5;
                particle.life = 0.5;
                particle.size = 2;
                particle.color = '#ff0000';
            }
        }
    }
    
    function handleMiss(puck, index) {
        showAnnouncement('MISS!');
        pucks.splice(index, 1);
        updateUI();
    }
    
    function updateParticles(dt) {
        particlePool.forEach(p => {
            if (!p.active) return;
            
            p.x += p.vx * dt * 60;
            p.y += p.vy * dt * 60;
            p.z += p.vz * dt * 60;
            p.vy += 18 * dt;
            p.life -= 1.2 * dt;
            
            if (p.life <= 0) {
                p.active = false;
            }
        });
    }
    
    function showAnnouncement(text) {
        announcementEl.textContent = text;
        announcementEl.classList.add('show');
        setTimeout(() => announcementEl.classList.remove('show'), 1500);
    }
    
    function updateUI() {
        scoreEl.textContent = score;
        shotsEl.textContent = shots;
        savesEl.textContent = saves;
    }
    
    function drawBackground() {
        if (backgroundRendered) return;
        
        // Clear background canvas
        bgCtx.clearRect(0, 0, bgCanvas.width, bgCanvas.height);
        
        // Ice surface with gradient
        const gradient = bgCtx.createLinearGradient(0, 0, 0, bgCanvas.height);
        gradient.addColorStop(0, '#e6f2ff');
        gradient.addColorStop(1, '#d0e4f7');
        bgCtx.fillStyle = gradient;
        bgCtx.fillRect(0, 0, bgCanvas.width, bgCanvas.height);
        
        // Ice texture
        bgCtx.fillStyle = 'rgba(200, 220, 240, 0.3)';
        for (let i = 0; i < 20; i++) {
            const y = bgCanvas.height * (i / 20);
            bgCtx.fillRect(0, y, bgCanvas.width, 2);
        }
        
        // Draw rink lines with perspective
        bgCtx.strokeStyle = '#ff0000';
        bgCtx.lineWidth = 4;
        
        // Goal line
        const goalLineNear = project3D(-200, 0, NET_DISTANCE - 50);
        const goalLineFar = project3D(200, 0, NET_DISTANCE - 50);
        bgCtx.beginPath();
        bgCtx.moveTo(goalLineNear.x, goalLineNear.y);
        bgCtx.lineTo(goalLineFar.x, goalLineNear.y);
        bgCtx.stroke();
        
        // Blue line
        const blueLineNear = project3D(-300, 0, 200);
        const blueLineFar = project3D(300, 0, 200);
        bgCtx.strokeStyle = '#0000ff';
        bgCtx.beginPath();
        bgCtx.moveTo(blueLineNear.x, blueLineNear.y);
        bgCtx.lineTo(blueLineFar.x, blueLineNear.y);
        bgCtx.stroke();
        
        // Draw net
        drawNet(bgCtx);
        
        backgroundRendered = true;
    }
    
    function drawNet(context) {
        const netWidth = 300;
        const netHeight = 150;
        const netDepth = 80;
        const netTop = -90;
        
        // Net back
        context.fillStyle = 'rgba(255, 255, 255, 0.8)';
        const topLeft = project3D(-netWidth/2, netTop, NET_DISTANCE + netDepth);
        const topRight = project3D(netWidth/2, netTop, NET_DISTANCE + netDepth);
        const bottomLeft = project3D(-netWidth/2, netTop + netHeight, NET_DISTANCE + netDepth);
        const bottomRight = project3D(netWidth/2, netTop + netHeight, NET_DISTANCE + netDepth);
        
        context.beginPath();
        context.moveTo(topLeft.x, topLeft.y);
        context.lineTo(topRight.x, topRight.y);
        context.lineTo(bottomRight.x, bottomRight.y);
        context.lineTo(bottomLeft.x, bottomLeft.y);
        context.closePath();
        context.fill();
        
        // Net mesh - batch draw
        context.strokeStyle = 'rgba(200, 200, 200, 0.5)';
        context.lineWidth = 1;
        context.beginPath();
        
        // Vertical lines
        for (let i = 0; i <= 20; i++) {
            const x = -netWidth/2 + (i * netWidth/20);
            const top = project3D(x, netTop, NET_DISTANCE + netDepth);
            const bottom = project3D(x, netTop + netHeight, NET_DISTANCE + netDepth);
            context.moveTo(top.x, top.y);
            context.lineTo(bottom.x, bottom.y);
        }
        
        context.stroke();
        
        // Posts
        context.fillStyle = '#ff0000';
        context.strokeStyle = '#aa0000';
        context.lineWidth = 4;
        
        // Left post
        const leftPostTop = project3D(-netWidth/2, netTop, NET_DISTANCE);
        const leftPostBottom = project3D(-netWidth/2, netTop + netHeight, NET_DISTANCE);
        context.beginPath();
        context.moveTo(leftPostTop.x, leftPostTop.y);
        context.lineTo(leftPostBottom.x, leftPostBottom.y);
        context.stroke();
        
        // Right post
        const rightPostTop = project3D(netWidth/2, netTop, NET_DISTANCE);
        const rightPostBottom = project3D(netWidth/2, netTop + netHeight, NET_DISTANCE);
        context.beginPath();
        context.moveTo(rightPostTop.x, rightPostTop.y);
        context.lineTo(rightPostBottom.x, rightPostBottom.y);
        context.stroke();
        
        // Crossbar
        context.beginPath();
        context.moveTo(leftPostTop.x, leftPostTop.y);
        context.lineTo(rightPostTop.x, rightPostTop.y);
        context.stroke();
    }
    
    function drawGoalie() {
        if (gameMode === 'practice') return;
        
        const pos = project3D(goalie.x, goalie.y, goalie.z);
        const size = 120 * pos.scale;
        
        // Shadow
        ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
        ctx.beginPath();
        ctx.ellipse(pos.x, pos.y + size/2, size * 0.8, size * 0.2, 0, 0, Math.PI * 2);
        ctx.fill();
        
        // Goalie body based on stance
        ctx.save();
        ctx.translate(pos.x, pos.y);
        
        if (goalie.stance === 'butterfly') {
            // Butterfly save position
            ctx.fillStyle = '#000080';
            ctx.fillRect(-size*0.8, -size*0.2, size*1.6, size*0.6);
            
            // Pads
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(-size*0.8, -size*0.1, size*0.7, size*0.5);
            ctx.fillRect(size*0.1, -size*0.1, size*0.7, size*0.5);
        } else {
            // Standing position
            ctx.fillStyle = '#000080';
            ctx.fillRect(-size*0.4, -size*0.6, size*0.8, size*1.2);
            
            // Pads
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(-size*0.35, 0, size*0.3, size*0.6);
            ctx.fillRect(size*0.05, 0, size*0.3, size*0.6);
        }
        
        // Glove
        const gloveOffset = goalie.stance === 'glove' ? -size*0.3 : 0;
        ctx.fillStyle = '#8B4513';
        ctx.beginPath();
        ctx.arc(-size*0.5, -size*0.2 + gloveOffset, size*0.2, 0, Math.PI * 2);
        ctx.fill();
        
        // Blocker
        const blockerOffset = goalie.stance === 'blocker' ? -size*0.3 : 0;
        ctx.fillStyle = '#8B4513';
        ctx.fillRect(size*0.3, -size*0.3 + blockerOffset, size*0.25, size*0.4);
        
        // Mask
        ctx.fillStyle = '#ffffff';
        ctx.fillRect(-size*0.2, -size*0.8, size*0.4, size*0.3);
        
        // Mask cage
        ctx.strokeStyle = '#000000';
        ctx.lineWidth = 2;
        for (let i = 0; i < 4; i++) {
            ctx.beginPath();
            ctx.moveTo(-size*0.2 + i*size*0.13, -size*0.8);
            ctx.lineTo(-size*0.2 + i*size*0.13, -size*0.5);
            ctx.stroke();
        }
        
        ctx.restore();
        
        // Save animation flash
        if (goalie.saveAnimation > 0) {
            ctx.fillStyle = `rgba(255, 255, 0, ${goalie.saveAnimation * 0.5})`;
            ctx.beginPath();
            ctx.arc(pos.x, pos.y, size * 1.5 * goalie.saveAnimation, 0, Math.PI * 2);
            ctx.fill();
        }
    }
    
    function drawPuck(puck) {
        const pos = project3D(puck.x, puck.y, puck.z);
        const size = puck.size * pos.scale;
        
        // Draw trail
        if (puck.trail.length > 1) {
            ctx.strokeStyle = 'rgba(0, 0, 0, 0.3)';
            ctx.lineWidth = size * 0.5;
            ctx.beginPath();
            for (let i = 0; i < puck.trail.length; i++) {
                const trailPos = project3D(puck.trail[i].x, puck.trail[i].y, puck.trail[i].z);
                if (i === 0) {
                    ctx.moveTo(trailPos.x, trailPos.y);
                } else {
                    ctx.lineTo(trailPos.x, trailPos.y);
                }
            }
            ctx.stroke();
        }
        
        // Puck shadow
        const shadowY = 0;
        const shadowPos = project3D(puck.x, shadowY, puck.z);
        ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
        ctx.beginPath();
        ctx.ellipse(shadowPos.x, shadowPos.y, size * 1.5, size * 0.5, 0, 0, Math.PI * 2);
        ctx.fill();
        
        // Draw puck
        ctx.save();
        ctx.translate(pos.x, pos.y);
        ctx.rotate(puck.rotation);
        
        // Puck body
        ctx.fillStyle = '#000000';
        ctx.beginPath();
        ctx.arc(0, 0, size, 0, Math.PI * 2);
        ctx.fill();
        
        // Puck detail
        ctx.strokeStyle = '#333333';
        ctx.lineWidth = size * 0.2;
        ctx.beginPath();
        ctx.arc(0, 0, size * 0.7, 0, Math.PI * 2);
        ctx.stroke();
        
        ctx.restore();
    }
    
    function drawRebound(rebound) {
        const pos = project3D(rebound.x, rebound.y, rebound.z);
        const size = rebound.size * pos.scale;
        
        ctx.fillStyle = '#000000';
        ctx.beginPath();
        ctx.arc(pos.x, pos.y, size, 0, Math.PI * 2);
        ctx.fill();
    }
    
    function drawParticles() {
        particlePool.forEach(p => {
            if (!p.active) return;
            
            const pos = project3D(p.x, p.y, p.z);
            const size = p.size * pos.scale * p.life;
            
            ctx.fillStyle = p.color || `rgba(255, 255, 255, ${p.life})`;
            ctx.beginPath();
            ctx.arc(pos.x, pos.y, size, 0, Math.PI * 2);
            ctx.fill();
        });
    }
    
    function drawStick() {
        if (!isCharging && pucks.length === 0) {
            const centerX = canvas.width / 2;
            const centerY = canvas.height - 100;
            const angle = Math.atan2(mouseY - centerY, mouseX - centerX);
            const stickX = centerX + Math.cos(angle) * 100;
            const stickY = centerY + Math.sin(angle) * 100;
            
            // Stick shaft
            ctx.strokeStyle = '#8B4513';
            ctx.lineWidth = 8;
            ctx.beginPath();
            ctx.moveTo(centerX, centerY);
            ctx.lineTo(stickX, stickY);
            ctx.stroke();
            
            // Blade
            ctx.fillStyle = '#000000';
            ctx.save();
            ctx.translate(stickX, stickY);
            ctx.rotate(angle + Math.PI / 2);
            ctx.fillRect(-5, 0, 10, 30);
            ctx.restore();
        }
    }
    
    function gameLoop(currentTime) {
        if (!gameActive) return;
        
        // Calculate delta time
        deltaTime = Math.min((currentTime - lastTime) / 1000, 0.1); // Cap at 0.1 to prevent huge jumps
        lastTime = currentTime;
        
        // Clear game canvas only
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // Draw static background
        drawBackground();
        
        // Update game objects with delta time
        updateGoalie(deltaTime);
        updatePucks(deltaTime);
        updateParticles(deltaTime);
        
        // Update charge power
        if (isCharging) {
            shotPower = Math.min(shotPower + 0.9 * deltaTime, 1);
            powerFillEl.style.width = (shotPower * 100) + '%';
        }
        
        // Draw dynamic elements
        rebounds.forEach(rebound => drawRebound(rebound));
        drawParticles();
        drawGoalie();
        pucks.forEach(puck => drawPuck(puck));
        drawStick();
        
        // Check game over conditions
        if (gameMode === 'classic' && shots >= 5 && pucks.length === 0) {
            endGame();
            return;
        }
        
        requestAnimationFrame(gameLoop);
    }
    
    function endGame() {
        gameActive = false;
        
        // Calculate stats
        const accuracy = shots > 0 ? Math.round(((shots - saves) / shots) * 100) : 0;
        const goals = shots - saves;
        
        // Update game over screen
        document.getElementById('finalScore').textContent = score;
        document.getElementById('finalAccuracy').textContent = accuracy + '%';
        document.getElementById('finalGoals').textContent = goals + '/' + shots;
        
        // Show game over screen
        setTimeout(() => {
            gameOverScreenEl.style.display = 'block';
        }, 1500);
    }
    
    function playAgain() {
        gameOverScreenEl.style.display = 'none';
        startGame(gameMode);
    }
    
    function returnToMenu() {
        // Stop the game
        gameActive = false;
        
        // Reset game state
        score = 0;
        shots = 0;
        saves = 0;
        shotPower = 0;
        isCharging = false;
        pucks = [];
        rebounds = [];
        particlePool.forEach(p => p.active = false);
        
        // Reset goalie
        goalie.x = 0;
        goalie.y = 0;
        goalie.stance = 'ready';
        goalie.saveAnimation = 0;
        goalie.stanceTimer = 0;
        
        // Reset UI
        powerFillEl.style.width = '0%';
        crosshairEl.classList.remove('show');
        updateUI();
        
        // Clear announcements
        announcementEl.classList.remove('show');
        
        // Show start screen, hide others
        startScreenEl.style.display = 'flex';
        homeBtnEl.style.display = 'none';
        gameOverScreenEl.style.display = 'none';
        
        if (canVibrate) navigator.vibrate(10);
    }
    
    // Initialize UI
    updateUI();
</script>
```

</body>
</html>