<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>RETRO HOCKEY SHOOTOUT</title>
    
    <!-- Mobile Optimizations -->
    <link rel="manifest" href="manifest.json">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="theme-color" content="#000000">
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='0.9em' font-size='90'>üèí</text></svg>">
    
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
        }
        
        body {
            font-family: 'Press Start 2P', monospace;
            background: #000;
            color: #fff;
            overflow: hidden;
            touch-action: none;
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        
        #gameCanvas, #backgroundCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            cursor: crosshair;
            image-rendering: pixelated;
        }
        
        #backgroundCanvas {
            z-index: 1;
        }
        
        #gameCanvas {
            z-index: 2;
        }
        
        .ui-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            z-index: 5;
        }
        
        .scoreboard {
            background: linear-gradient(to bottom, #2a2a2a 0%, #1a1a1a 50%, #0a0a0a 100%);
            border: 3px solid #444;
            border-radius: 10px;
            padding: 15px;
            margin: 10px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.8);
            display: flex;
            justify-content: space-around;
            align-items: center;
            max-width: 600px;
            margin: 10px auto;
        }
        
        .score-section {
            text-align: center;
        }
        
        .score-label {
            font-size: 10px;
            color: #888;
            margin-bottom: 5px;
        }
        
        .score-value {
            font-size: 20px;
            color: #0ff;
            text-shadow: 0 0 10px #0ff;
        }
        
        .divider {
            width: 2px;
            height: 40px;
            background: #444;
        }
        
        /* Vertical power meter with retro style */
        .power-meter-container {
            position: fixed;
            left: 20px;
            top: 50%;
            transform: translateY(-50%);
            display: none;
            z-index: 20;
            pointer-events: none;
        }
        
        .power-meter {
            width: 40px;
            height: 200px;
            border: 3px solid #fff;
            background: #000;
            overflow: hidden;
            position: relative;
            box-shadow: inset 0 0 10px rgba(0,0,0,0.5);
        }
        
        .power-segments {
            position: absolute;
            bottom: 0;
            width: 100%;
            height: 100%;
        }
        
        .power-segment {
            width: 100%;
            height: 10%;
            border-top: 1px solid #333;
            box-sizing: border-box;
        }
        
        .power-fill {
            width: 100%;
            height: 0%;
            background: linear-gradient(to top, #00ff00, #ffff00 50%, #ff0000);
            position: absolute;
            bottom: 0;
            transition: height 0.1s;
            box-shadow: 0 0 20px currentColor;
        }
        
        .power-label {
            writing-mode: vertical-rl;
            text-orientation: mixed;
            position: absolute;
            right: -25px;
            top: 50%;
            transform: translateY(-50%);
            font-size: 10px;
            color: #ff0;
            text-shadow: 2px 2px 0 #000;
        }
        
        .shot-type {
            position: fixed;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 12px;
            color: #fff;
            text-shadow: 2px 2px 0 #000;
            background: #000;
            border: 2px solid #fff;
            padding: 8px 15px;
            z-index: 20;
            display: none;
        }
        
        .controls {
            position: fixed;
            bottom: 130px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            font-size: 10px;
            color: #888;
            text-shadow: 2px 2px 0 #000;
            z-index: 20;
            display: none;
        }
        
        .shot-selector {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: none;
            gap: 10px;
            pointer-events: all;
            z-index: 20;
        }
        
        .shot-button {
            background: #222;
            border: 3px solid #666;
            color: #fff;
            padding: 10px 15px;
            font-family: 'Press Start 2P', monospace;
            font-size: 10px;
            cursor: pointer;
            transition: all 0.1s;
            pointer-events: all;
            text-shadow: 2px 2px 0 #000;
        }
        
        .shot-button:hover {
            transform: scale(1.05);
        }
        
        .shot-button.active {
            background: #ff0000;
            border-color: #ff0000;
            box-shadow: 0 0 20px rgba(255,0,0,0.6);
        }
        
        .home-button {
            position: fixed;
            top: 80px;
            right: 10px;
            width: 50px;
            height: 50px;
            background: #222;
            border: 3px solid #fff;
            cursor: pointer;
            display: none;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            pointer-events: all;
            z-index: 10;
            color: #fff;
        }
        
        .home-button:hover {
            background: #ff0000;
            transform: scale(1.1);
        }
        
        .announcement {
            position: fixed;
            top: 30%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 24px;
            font-weight: bold;
            color: #ff0000;
            text-shadow: 3px 3px 0 #000, -1px -1px 0 #fff;
            opacity: 0;
            pointer-events: none;
            z-index: 20;
            letter-spacing: 2px;
        }
        
        .announcement.show {
            animation: announce 1.5s ease-out;
        }
        
        .announcement.goal {
            font-size: 32px;
            color: #ffff00;
            text-shadow: 4px 4px 0 #ff0000, -2px -2px 0 #fff;
            animation: goalAnnounce 2s ease-out;
        }
        
        @keyframes announce {
            0% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
            50% { opacity: 1; transform: translate(-50%, -50%) scale(1.2); }
            100% { opacity: 0; transform: translate(-50%, -50%) scale(1); }
        }
        
        @keyframes goalAnnounce {
            0% { 
                opacity: 0; 
                transform: translate(-50%, -50%) scale(0.3) rotate(-10deg); 
            }
            40% { 
                opacity: 1; 
                transform: translate(-50%, -50%) scale(1.3) rotate(5deg); 
            }
            60% { 
                transform: translate(-50%, -50%) scale(1.1) rotate(-2deg); 
            }
            100% { 
                opacity: 0; 
                transform: translate(-50%, -50%) scale(1) rotate(0deg); 
            }
        }
        
        #startScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(180deg, #0a0a1e, #000);
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            align-items: center;
            z-index: 100;
            padding: 20px;
            overflow-y: auto;
        }
        
        #startScreen h1 {
            font-size: 28px;
            color: #0ff;
            text-shadow: 4px 4px 0 #000, 0 0 20px #0ff;
            margin: 30px 0 20px 0;
            text-align: center;
            line-height: 1.4;
        }
        
        .difficulty-selector {
            display: flex;
            gap: 10px;
            margin-bottom: 30px;
            justify-content: center;
        }
        
        .difficulty-label {
            color: #888;
            margin-bottom: 15px;
            font-size: 12px;
            text-align: center;
        }
        
        .menu-buttons {
            display: flex;
            flex-direction: column;
            gap: 15px;
            width: 100%;
            max-width: 300px;
        }
        
        .menu-button {
            background: #222;
            border: 3px solid #666;
            color: #fff;
            padding: 15px 20px;
            font-family: 'Press Start 2P', monospace;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.1s;
            text-transform: uppercase;
            width: 100%;
            text-shadow: 2px 2px 0 #000;
        }
        
        .menu-button:hover {
            background: #ff0000;
            border-color: #ff0000;
            transform: scale(1.05);
            box-shadow: 0 0 20px rgba(255,0,0,0.5);
        }
        
        .difficulty-button {
            background: #222;
            border: 3px solid #666;
            color: #fff;
            padding: 8px 12px;
            font-family: 'Press Start 2P', monospace;
            font-size: 10px;
            cursor: pointer;
            transition: all 0.1s;
        }
        
        .difficulty-button.active {
            background: #ff0000;
            border-color: #ff0000;
        }
        
        .difficulty-button[data-difficulty="easy"] {
            border-color: #4CAF50;
        }
        
        .difficulty-button[data-difficulty="easy"].active {
            background: #4CAF50;
        }
        
        .difficulty-button[data-difficulty="medium"] {
            border-color: #FFC107;
        }
        
        .difficulty-button[data-difficulty="medium"].active {
            background: #FFC107;
        }
        
        .difficulty-button[data-difficulty="hard"] {
            border-color: #f44336;
        }
        
        .difficulty-button[data-difficulty="hard"].active {
            background: #f44336;
        }
        
        .rebound-alert {
            position: fixed;
            top: 45%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 16px;
            color: #ffff00;
            text-shadow: 2px 2px 0 #000;
            opacity: 0;
            pointer-events: none;
        }
        
        .rebound-alert.show {
            animation: reboundPulse 1s ease-out;
        }
        
        @keyframes reboundPulse {
            0% { opacity: 0; transform: translate(-50%, -50%) scale(0.8); }
            50% { opacity: 1; transform: translate(-50%, -50%) scale(1.1); }
            100% { opacity: 0; transform: translate(-50%, -50%) scale(1); }
        }
        
        .crosshair {
            position: absolute;
            width: 50px;
            height: 50px;
            opacity: 0.8;
            pointer-events: none;
            transform: translate(-50%, -50%);
            display: none;
            z-index: 15;
        }
        
        .crosshair::before,
        .crosshair::after {
            content: '';
            position: absolute;
            background: #0ff;
            box-shadow: 0 0 5px #0ff;
        }
        
        .crosshair::before {
            width: 2px;
            height: 50px;
            left: 50%;
            top: 0;
            transform: translateX(-50%);
        }
        
        .crosshair::after {
            width: 50px;
            height: 2px;
            left: 0;
            top: 50%;
            transform: translateY(-50%);
        }
        
        .crosshair.show {
            display: block;
        }
        
        .game-over-screen {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #000;
            border: 3px solid #0ff;
            padding: 30px;
            text-align: center;
            display: none;
            z-index: 50;
            width: 90%;
            max-width: 400px;
            box-shadow: 0 0 30px rgba(0,255,255,0.5);
        }
        
        .game-over-screen h2 {
            color: #ff0000;
            font-size: 20px;
            margin-bottom: 20px;
            text-shadow: 3px 3px 0 #000;
        }
        
        .stats-row {
            display: flex;
            justify-content: space-between;
            margin: 10px 0;
            font-size: 12px;
            color: #0ff;
        }
        
        .game-over-buttons {
            display: flex;
            gap: 15px;
            margin-top: 25px;
            justify-content: center;
            flex-wrap: wrap;
        }
        
        .game-over-button {
            background: #222;
            border: 3px solid #666;
            color: #fff;
            padding: 10px 15px;
            font-family: 'Press Start 2P', monospace;
            font-size: 10px;
            cursor: pointer;
            transition: all 0.1s;
        }
        
        .game-over-button:hover {
            background: #ff0000;
            border-color: #ff0000;
            transform: scale(1.05);
        }
    </style>
</head>
<body>
    <canvas id="backgroundCanvas"></canvas>
    <canvas id="gameCanvas"></canvas>
    
    <div class="ui-overlay">
        <div class="scoreboard">
            <div class="score-section">
                <div class="score-label">SCORE</div>
                <div class="score-value" id="score">0</div>
            </div>
            <div class="divider"></div>
            <div class="score-section">
                <div class="score-label">SHOTS</div>
                <div class="score-value" id="shots">0</div>
            </div>
            <div class="divider"></div>
            <div class="score-section">
                <div class="score-label">SAVES</div>
                <div class="score-value" id="saves">0</div>
            </div>
        </div>
    </div>
    
    <button class="home-button" id="homeBtn" title="Return to Menu" aria-label="Return to main menu">üè†</button>
    
    <div class="announcement" id="announcement"></div>
    <div class="rebound-alert" id="reboundAlert">REBOUND!</div>
    
    <div class="power-meter-container" id="powerMeterContainer">
        <div class="power-label">POWER</div>
        <div class="power-meter">
            <div class="power-segments">
                <div class="power-segment"></div>
                <div class="power-segment"></div>
                <div class="power-segment"></div>
                <div class="power-segment"></div>
                <div class="power-segment"></div>
                <div class="power-segment"></div>
                <div class="power-segment"></div>
                <div class="power-segment"></div>
                <div class="power-segment"></div>
                <div class="power-segment"></div>
            </div>
            <div class="power-fill" id="powerFill"></div>
        </div>
    </div>
    
    <div class="shot-type" id="shotType">WRIST SHOT</div>
    
    <div class="controls">
        SWIPE TO SHOOT ‚Ä¢ DISTANCE = POWER
    </div>
    
    <div class="shot-selector">
        <button class="shot-button active" id="wristBtn" aria-label="Select wrist shot">WRIST</button>
        <button class="shot-button" id="slapBtn" aria-label="Select slap shot">SLAP</button>
        <button class="shot-button" id="backhandBtn" aria-label="Select backhand shot">BACKHAND</button>
    </div>
    
    <div class="crosshair" id="crosshair"></div>
    
    <div class="game-over-screen" id="gameOverScreen">
        <h2>GAME OVER!</h2>
        <div class="stats-row">
            <span>Final Score:</span>
            <span id="finalScore">0</span>
        </div>
        <div class="stats-row">
            <span>Accuracy:</span>
            <span id="finalAccuracy">0%</span>
        </div>
        <div class="stats-row">
            <span>Goals:</span>
            <span id="finalGoals">0/0</span>
        </div>
        <div class="game-over-buttons">
            <button class="game-over-button" onclick="playAgain()">PLAY AGAIN</button>
            <button class="game-over-button" onclick="returnToMenu()">MENU</button>
        </div>
    </div>
    
    <div id="startScreen">
        <h1>RETRO<br>HOCKEY<br>SHOOTOUT</h1>
        <div class="difficulty-label">SELECT DIFFICULTY</div>
        <div class="difficulty-selector">
            <button class="difficulty-button" id="easyBtn" data-difficulty="easy" aria-label="Easy difficulty">EASY</button>
            <button class="difficulty-button active" id="mediumBtn" data-difficulty="medium" aria-label="Medium difficulty">MEDIUM</button>
            <button class="difficulty-button" id="hardBtn" data-difficulty="hard" aria-label="Hard difficulty">HARD</button>
        </div>
        <div class="menu-buttons">
            <button class="menu-button" id="classicBtn" aria-label="Classic mode - 5 shots">CLASSIC MODE</button>
            <button class="menu-button" id="timeBtn" aria-label="Time attack mode - 60 seconds">TIME ATTACK</button>
            <button class="menu-button" id="suddenBtn" aria-label="Sudden death mode">SUDDEN DEATH</button>
            <button class="menu-button" id="practiceBtn" aria-label="Practice mode - no goalie">PRACTICE MODE</button>
        </div>
    </div>
    
    <script>
        // Get canvases
        const bgCanvas = document.getElementById('backgroundCanvas');
        const bgCtx = bgCanvas.getContext('2d');
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // Enable pixel art rendering
        bgCtx.imageSmoothingEnabled = false;
        ctx.imageSmoothingEnabled = false;
        
        // Cache DOM elements
        const scoreEl = document.getElementById('score');
        const shotsEl = document.getElementById('shots');
        const savesEl = document.getElementById('saves');
        const shotTypeEl = document.getElementById('shotType');
        const powerFillEl = document.getElementById('powerFill');
        const crosshairEl = document.getElementById('crosshair');
        const announcementEl = document.getElementById('announcement');
        const reboundAlertEl = document.getElementById('reboundAlert');
        const startScreenEl = document.getElementById('startScreen');
        const homeBtnEl = document.getElementById('homeBtn');
        const gameOverScreenEl = document.getElementById('gameOverScreen');
        const powerMeterContainerEl = document.getElementById('powerMeterContainer');
        const controlsEl = document.querySelector('.controls');
        const shotSelectorEl = document.querySelector('.shot-selector');
        
        // Check for haptic support once
        const canVibrate = 'vibrate' in navigator;
        
        // Sound system foundation
        const sounds = {
            enabled: true,
            volume: 0.5,
            // Sound data URLs can be added here later
            // Example: shot: 'data:audio/wav;base64,...'
        };
        
        function playSound(soundName, volume = 1.0) {
            if (!sounds.enabled || !sounds[soundName]) return;
            
            try {
                const audio = new Audio(sounds[soundName]);
                audio.volume = sounds.volume * volume;
                audio.play().catch(() => {
                    // Ignore audio play errors (common on mobile)
                });
            } catch (e) {
                // Ignore audio errors
            }
        }
        
        // Game state
        let gameMode = 'classic';
        let gameActive = false;
        let gamePaused = false;
        let score = 0;
        let shots = 0;
        let saves = 0;
        let shotPower = 0;
        let isCharging = false;
        let mouseX = 0;
        let mouseY = 0;
        let shotType = 'wrist';
        let difficulty = 'medium';
        let lastTime = 0;
        let deltaTime = 0;
        let animationFrame = 0;
        
        // Swipe controls
        let touchStartX = 0;
        let touchStartY = 0;
        let touchStartTime = 0;
        let isSwiping = false;
        let swipePreview = null;
        
        // Screen shake
        let screenShake = 0;
        let screenShakeX = 0;
        let screenShakeY = 0;
        
        // 3D perspective constants adjusted for portrait
        const PERSPECTIVE = 600;
        const NET_DISTANCE = 300;
        const NET_Y_OFFSET = -100;
        
        // Object pools - reduced for mobile performance
        const particlePool = [];
        const MAX_PARTICLES = 50;
        
        // Initialize particle pool
        for (let i = 0; i < MAX_PARTICLES; i++) {
            particlePool.push({
                active: false,
                x: 0, y: 0, z: 0,
                vx: 0, vy: 0, vz: 0,
                life: 0, size: 0, color: null,
                type: 'ice'
            });
        }
        
        function getParticle() {
            for (let p of particlePool) {
                if (!p.active) {
                    p.active = true;
                    return p;
                }
            }
            return null;
        }
        
        // Game objects
        let pucks = [];
        let goalie = {
            x: 0,
            y: NET_Y_OFFSET,
            z: NET_DISTANCE,
            targetX: 0,
            targetY: NET_Y_OFFSET,
            vx: 0,
            vy: 0,
            stance: 'ready',
            saveAnimation: 0,
            speed: 0.1,
            prediction: 0.7,
            stanceTimer: 0,
            animationFrame: 0,
            facing: 'center'
        };
        
        let player = {
            x: 0,
            y: 50,
            z: 0,
            animationFrame: 0,
            shooting: false,
            shootTimer: 0
        };
        
        let particles = [];
        let rebounds = [];
        let backgroundRendered = false;
        let stars = [];
        
        // Initialize stars for background
        for (let i = 0; i < 50; i++) {
            stars.push({
                x: Math.random() * 1000 - 500,
                y: Math.random() * 200 - 100,
                z: Math.random() * 500,
                size: Math.random() * 2 + 1
            });
        }
        
        // Canvas setup
        function resizeCanvas() {
            bgCanvas.width = canvas.width = window.innerWidth;
            bgCanvas.height = canvas.height = window.innerHeight;
            backgroundRendered = false;
        }
        
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();
        
        // Event listeners - Mobile-first swipe controls
        canvas.addEventListener('touchstart', handleTouchStart, { passive: false });
        canvas.addEventListener('touchmove', handleTouchMove, { passive: false });
        canvas.addEventListener('touchend', handleTouchEnd, { passive: false });
        
        // Mouse fallback for desktop
        canvas.addEventListener('mousedown', handleMouseDown);
        canvas.addEventListener('mousemove', handleMouseMove);
        canvas.addEventListener('mouseup', handleMouseUp);
        
        // Button event listeners
        document.getElementById('wristBtn').addEventListener('click', () => selectShot('wrist'));
        document.getElementById('slapBtn').addEventListener('click', () => selectShot('slap'));
        document.getElementById('backhandBtn').addEventListener('click', () => selectShot('backhand'));
        
        document.getElementById('easyBtn').addEventListener('click', () => setDifficulty('easy'));
        document.getElementById('mediumBtn').addEventListener('click', () => setDifficulty('medium'));
        document.getElementById('hardBtn').addEventListener('click', () => setDifficulty('hard'));
        
        document.getElementById('classicBtn').addEventListener('click', () => startGame('classic'));
        document.getElementById('timeBtn').addEventListener('click', () => startGame('timeattack'));
        document.getElementById('suddenBtn').addEventListener('click', () => startGame('sudden'));
        document.getElementById('practiceBtn').addEventListener('click', () => startGame('practice'));
        
        homeBtnEl.addEventListener('click', returnToMenu);
        
        function selectShot(type) {
            shotType = type;
            shotTypeEl.textContent = type.toUpperCase() + ' SHOT';
            
            document.querySelectorAll('.shot-button').forEach(btn => btn.classList.remove('active'));
            document.getElementById(type + 'Btn').classList.add('active');
            
            if (canVibrate) navigator.vibrate(10);
        }
        
        function setDifficulty(level) {
            difficulty = level;
            
            switch(level) {
                case 'easy':
                    goalie.speed = 0.05;
                    goalie.prediction = 0.5;
                    break;
                case 'medium':
                    goalie.speed = 0.1;
                    goalie.prediction = 0.7;
                    break;
                case 'hard':
                    goalie.speed = 0.15;
                    goalie.prediction = 0.9;
                    break;
            }
            
            document.querySelectorAll('.difficulty-button').forEach(btn => btn.classList.remove('active'));
            document.getElementById(level + 'Btn').classList.add('active');
        }
        
        // Touch control functions
        function handleTouchStart(e) {
            if (!gameActive || isSwiping) return;
            e.preventDefault();
            
            const touch = e.touches[0];
            touchStartX = touch.clientX;
            touchStartY = touch.clientY;
            touchStartTime = Date.now();
            isSwiping = true;
            
            // Initialize swipe preview
            swipePreview = {
                startX: touchStartX,
                startY: touchStartY,
                currentX: touchStartX,
                currentY: touchStartY,
                power: 0
            };
            
            if (canVibrate) navigator.vibrate(10);
        }
        
        function handleTouchMove(e) {
            if (!gameActive || !isSwiping) return;
            e.preventDefault();
            
            const touch = e.touches[0];
            const currentX = touch.clientX;
            const currentY = touch.clientY;
            
            // Update swipe preview
            swipePreview.currentX = currentX;
            swipePreview.currentY = currentY;
            
            // Calculate swipe distance for power
            const dx = currentX - touchStartX;
            const dy = currentY - touchStartY;
            const distance = Math.sqrt(dx * dx + dy * dy);
            swipePreview.power = Math.min(distance / 200, 1);
            
            // Update power meter
            powerFillEl.style.height = (swipePreview.power * 100) + '%';
            powerMeterContainerEl.style.display = 'block';
        }
        
        function handleTouchEnd(e) {
            if (!gameActive || !isSwiping) return;
            e.preventDefault();
            
            const swipeTime = Date.now() - touchStartTime;
            const dx = swipePreview.currentX - touchStartX;
            const dy = swipePreview.currentY - touchStartY;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            // Minimum swipe distance to register as shot
            if (distance > 30) {
                const swipeSpeed = distance / swipeTime;
                shootWithSwipe(dx, dy, distance, swipeSpeed);
            }
            
            isSwiping = false;
            swipePreview = null;
            powerFillEl.style.height = '0%';
        }
        
        // Mouse control functions (fallback for desktop)
        function handleMouseDown(e) {
            if (!gameActive) return;
            touchStartX = e.clientX;
            touchStartY = e.clientY;
            touchStartTime = Date.now();
            isSwiping = true;
            
            swipePreview = {
                startX: touchStartX,
                startY: touchStartY,
                currentX: touchStartX,
                currentY: touchStartY,
                power: 0
            };
        }
        
        function handleMouseMove(e) {
            mouseX = e.clientX;
            mouseY = e.clientY;
            
            if (gameActive && isSwiping) {
                swipePreview.currentX = mouseX;
                swipePreview.currentY = mouseY;
                
                const dx = mouseX - touchStartX;
                const dy = mouseY - touchStartY;
                const distance = Math.sqrt(dx * dx + dy * dy);
                swipePreview.power = Math.min(distance / 200, 1);
                
                powerFillEl.style.height = (swipePreview.power * 100) + '%';
                powerMeterContainerEl.style.display = 'block';
            }
            
            // Update crosshair
            if (gameActive) {
                crosshairEl.classList.add('show');
                crosshairEl.style.left = mouseX + 'px';
                crosshairEl.style.top = mouseY + 'px';
            } else {
                crosshairEl.classList.remove('show');
            }
        }
        
        function handleMouseUp(e) {
            if (!gameActive || !isSwiping) return;
            
            const swipeTime = Date.now() - touchStartTime;
            const dx = swipePreview.currentX - touchStartX;
            const dy = swipePreview.currentY - touchStartY;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            if (distance > 30) {
                const swipeSpeed = distance / swipeTime;
                shootWithSwipe(dx, dy, distance, swipeSpeed);
            }
            
            isSwiping = false;
            swipePreview = null;
            powerFillEl.style.height = '0%';
        }
        
        function shootWithSwipe(dx, dy, distance, swipeSpeed) {
            shots++;
            updateUI();
            
            player.shooting = true;
            player.shootTimer = 0;
            
            // Calculate shot power based on swipe distance and speed
            shotPower = Math.min((distance / 200) * (swipeSpeed / 0.5), 1);
            
            // Shot properties based on type
            let velocity, accuracy, elevation;
            
            switch(shotType) {
                case 'slap':
                    velocity = 25 + shotPower * 20;
                    accuracy = 0.7 - shotPower * 0.2;
                    elevation = 0.1 + Math.random() * 0.2;
                    break;
                case 'backhand':
                    velocity = 15 + shotPower * 10;
                    accuracy = 0.85;
                    elevation = 0.05 + Math.random() * 0.15;
                    break;
                default:
                    velocity = 20 + shotPower * 15;
                    accuracy = 0.9 - shotPower * 0.1;
                    elevation = 0.05 + Math.random() * 0.25;
            }
            
            // Calculate shot direction from swipe
            const angle = Math.atan2(-dy, dx); // Negative dy for intuitive up-swipe
            
            const baseVelocity = velocity;
            const aimX = Math.cos(angle) * baseVelocity;
            const aimY = Math.sin(angle) * baseVelocity * 0.5;
            const aimZ = Math.abs(Math.sin(angle)) * baseVelocity * 0.8;
            
            // Add accuracy spread
            const accuracySpread = (1 - accuracy) * 0.3;
            const vx = aimX + (Math.random() - 0.5) * accuracySpread * baseVelocity;
            const vy = aimY;
            const vz = aimZ + 15;
            
            const puck = {
                x: 0,
                y: 50,
                z: 0,
                vx: vx,
                vy: vy,
                vz: vz,
                size: 8,
                rotation: 0,
                rotationSpeed: Math.random() * 0.3 + 0.1,
                trail: [],
                spin: 0
            };
            
            pucks.push(puck);
            
            // Create ice spray - reduced for mobile
            for (let i = 0; i < 15; i++) {
                const particle = getParticle();
                if (particle) {
                    particle.x = 0;
                    particle.y = 50;
                    particle.z = 0;
                    particle.vx = (Math.random() - 0.5) * 8 - vx * 0.1;
                    particle.vy = -Math.random() * 5;
                    particle.vz = Math.random() * 3;
                    particle.life = 1;
                    particle.size = Math.random() * 4 + 1;
                    particle.color = null;
                    particle.type = 'ice';
                }
            }
            
            // Haptic feedback based on shot power
            if (canVibrate) {
                const vibrationStrength = Math.floor(25 + shotPower * 50);
                navigator.vibrate(vibrationStrength);
            }
            
            // Update goalie stance based on shot
            const goalieX = vx * (NET_DISTANCE / vz);
            const goalieY = vy * (NET_DISTANCE / vz);
            
            goalie.targetX = goalieX * goalie.prediction;
            goalie.targetY = NET_Y_OFFSET + Math.max(-50, Math.min(20, goalieY * 0.5));
            
            if (vy < -10) {
                goalie.stance = 'glove';
            } else if (vy > -5) {
                goalie.stance = 'butterfly';
            } else {
                goalie.stance = 'blocker';
            }
            goalie.stanceTimer = 0;
            
            // Update goalie facing
            if (goalieX < -50) goalie.facing = 'left';
            else if (goalieX > 50) goalie.facing = 'right';
            else goalie.facing = 'center';
        }
        
        function startGame(mode) {
            gameMode = mode;
            gameActive = true;
            score = 0;
            shots = 0;
            saves = 0;
            pucks = [];
            rebounds = [];
            
            particlePool.forEach(p => p.active = false);
            
            if (mode === 'practice') {
                goalie.x = 1000;
            } else {
                goalie.x = 0;
            }
            
            goalie.y = NET_Y_OFFSET;
            goalie.targetY = NET_Y_OFFSET;
            
            startScreenEl.style.display = 'none';
            homeBtnEl.style.display = 'flex';
            gameOverScreenEl.style.display = 'none';
            
            powerMeterContainerEl.style.display = 'block';
            shotTypeEl.style.display = 'block';
            controlsEl.style.display = 'block';
            shotSelectorEl.style.display = 'flex';
            
            updateUI();
            lastTime = performance.now();
            gameLoop(lastTime);
        }
        
        function project3D(x, y, z) {
            const scale = PERSPECTIVE / (PERSPECTIVE + z);
            return {
                x: canvas.width / 2 + x * scale,
                y: canvas.height / 3 + y * scale,
                scale: scale
            };
        }
        
        function updateGoalie(dt) {
            if (gameMode === 'practice') return;
            
            // Enhanced goalie AI - track puck if exists
            if (pucks.length > 0) {
                const closestPuck = pucks.reduce((closest, puck) => 
                    !closest || puck.z < closest.z ? puck : closest, null);
                
                if (closestPuck && closestPuck.z < NET_DISTANCE * 0.8) {
                    // Predict where puck will be when it reaches the net
                    const timeToNet = (NET_DISTANCE - closestPuck.z) / closestPuck.vz;
                    const predictedX = closestPuck.x + closestPuck.vx * timeToNet;
                    const predictedY = closestPuck.y + closestPuck.vy * timeToNet;
                    
                    goalie.targetX = predictedX * goalie.prediction;
                    goalie.targetY = NET_Y_OFFSET + Math.max(-50, Math.min(20, 
                        (predictedY - NET_Y_OFFSET) * goalie.prediction * 0.7));
                }
            }
            
            const dx = goalie.targetX - goalie.x;
            const dy = goalie.targetY - goalie.y;
            
            // More responsive movement
            goalie.vx += dx * goalie.speed * 80 * dt;
            goalie.vy += dy * goalie.speed * 80 * dt;
            goalie.vx *= Math.pow(0.85, 60 * dt);
            goalie.vy *= Math.pow(0.85, 60 * dt);
            
            goalie.x += goalie.vx * dt * 60;
            goalie.y += goalie.vy * dt * 60;
            
            // Clamp goalie position
            goalie.x = Math.max(-120, Math.min(120, goalie.x));
            goalie.y = Math.max(NET_Y_OFFSET - 60, Math.min(NET_Y_OFFSET + 30, goalie.y));
            
            if (goalie.saveAnimation > 0) {
                goalie.saveAnimation -= 3 * dt;
            }
            
            if (goalie.stanceTimer > 0) {
                goalie.stanceTimer -= 60 * dt;
                if (goalie.stanceTimer <= 0) {
                    goalie.stance = 'ready';
                }
            }
            
            if (pucks.length === 0 && goalie.stance !== 'ready' && goalie.stanceTimer === 0) {
                goalie.stanceTimer = 30;
            }
            
            // Update animation frame for idle animation
            goalie.animationFrame += dt * 10;
        }
        
        function updatePlayer(dt) {
            if (player.shooting) {
                player.shootTimer += dt * 60;
                if (player.shootTimer > 30) {
                    player.shooting = false;
                    player.shootTimer = 0;
                }
            }
            
            player.animationFrame += dt * 10;
        }
        
        function updatePucks(dt) {
            for (let i = pucks.length - 1; i >= 0; i--) {
                const puck = pucks[i];
                
                if (puck.z < NET_DISTANCE) {
                    // Optimized trail management
                    if (puck.trail.length > 10) {
                        puck.trail.shift();
                    }
                    puck.trail.push({ x: puck.x, y: puck.y, z: puck.z });
                }
                
                puck.x += puck.vx * dt * 60;
                puck.y += puck.vy * dt * 60;
                puck.z += puck.vz * dt * 60;
                
                puck.vy += 18 * dt;
                
                puck.vx *= Math.pow(0.99, 60 * dt);
                puck.vz *= Math.pow(0.99, 60 * dt);
                
                puck.rotation += puck.rotationSpeed * dt * 60;
                puck.spin += 0.2 * dt * 60;
                
                if (puck.z >= NET_DISTANCE) {
                    const netWidth = 200;
                    const netHeight = 100;
                    const netTop = NET_Y_OFFSET - 40;
                    
                    const inNet = Math.abs(puck.x) < netWidth / 2 && 
                                 puck.y > netTop && puck.y < netTop + netHeight;
                    
                    const goalieWidth = 70;
                    const goalieHeight = 90;
                    const hitGoalie = gameMode !== 'practice' &&
                                    Math.abs(puck.x - goalie.x) < goalieWidth / 2 &&
                                    Math.abs(puck.y - goalie.y) < goalieHeight / 2;
                    
                    if (hitGoalie) {
                        handleSave(puck, i);
                    } else if (inNet) {
                        handleGoal(puck, i);
                    } else {
                        if (Math.abs(puck.x) < netWidth / 2 + 10 && 
                            puck.y > netTop - 10 && puck.y < netTop + netHeight + 10) {
                            handlePost(puck, i);
                        } else {
                            handleMiss(puck, i);
                        }
                    }
                }
                
                if (puck.z > NET_DISTANCE + 200 || puck.y > 200) {
                    pucks.splice(i, 1);
                }
            }
            
            for (let i = rebounds.length - 1; i >= 0; i--) {
                const rebound = rebounds[i];
                rebound.x += rebound.vx * dt * 60;
                rebound.y += rebound.vy * dt * 60;
                rebound.z += rebound.vz * dt * 60;
                rebound.vy += 30 * dt;
                rebound.spin += 0.15 * dt * 60;
                
                if (rebound.y > 100 || rebound.z > NET_DISTANCE + 100) {
                    rebounds.splice(i, 1);
                }
            }
        }
        
        function handleSave(puck, index) {
            saves++;
            goalie.saveAnimation = 1;
            showAnnouncement('SAVE!');
            
            if (canVibrate) navigator.vibrate([50, 50, 50]);
            
            const rebound = {
                x: puck.x,
                y: puck.y,
                z: puck.z,
                vx: -puck.vx * 0.5 + (Math.random() - 0.5) * 10,
                vy: -5,
                vz: -puck.vz * 0.3,
                size: puck.size,
                spin: 0
            };
            rebounds.push(rebound);
            
            reboundAlertEl.classList.add('show');
            setTimeout(() => reboundAlertEl.classList.remove('show'), 1000);
            
            pucks.splice(index, 1);
            updateUI();
            
            if (gameMode === 'sudden' && saves > 0) {
                endGame();
            }
        }
        
        function handleGoal(puck, index) {
            score += 100;
            showAnnouncement('GOAL!!!');
            
            // Enhanced haptic feedback for goals
            if (canVibrate) navigator.vibrate([100, 50, 100, 50, 150]);
            
            // Trigger screen shake
            screenShake = 1;
            
            if (puck.y < NET_Y_OFFSET - 20) {
                score += 50;
                setTimeout(() => showAnnouncement('TOP SHELF!'), 500);
            } else if (puck.y > NET_Y_OFFSET + 20) {
                score += 30;
                setTimeout(() => showAnnouncement('FIVE HOLE!'), 500);
            }
            
            for (let i = 0; i < 30; i++) {
                const particle = getParticle();
                if (particle) {
                    particle.x = puck.x;
                    particle.y = puck.y;
                    particle.z = NET_DISTANCE;
                    particle.vx = (Math.random() - 0.5) * 25;
                    particle.vy = (Math.random() - 0.5) * 25;
                    particle.vz = (Math.random() - 0.5) * 15;
                    particle.life = 1;
                    particle.size = Math.random() * 6 + 2;
                    particle.color = `hsl(${Math.random() * 360}, 100%, 50%)`;
                    particle.type = 'celebration';
                }
            }
            
            pucks.splice(index, 1);
            updateUI();
        }
        
        function updateScreenShake(dt) {
            if (screenShake > 0) {
                screenShake -= dt * 3;
                const intensity = screenShake * 20;
                screenShakeX = (Math.random() - 0.5) * intensity;
                screenShakeY = (Math.random() - 0.5) * intensity;
            } else {
                screenShakeX = 0;
                screenShakeY = 0;
            }
        }
        
        function handlePost(puck, index) {
            showAnnouncement('POST!');
            puck.vx *= -0.8;
            puck.vz *= 0.5;
            
            if (canVibrate) navigator.vibrate(50);
            
            for (let i = 0; i < 15; i++) {
                const particle = getParticle();
                if (particle) {
                    particle.x = puck.x;
                    particle.y = puck.y;
                    particle.z = puck.z;
                    particle.vx = (Math.random() - 0.5) * 12;
                    particle.vy = -Math.random() * 8;
                    particle.vz = -Math.random() * 8;
                    particle.life = 0.8;
                    particle.size = 3;
                    particle.color = '#ff0000';
                    particle.type = 'spark';
                }
            }
        }
        
        function handleMiss(puck, index) {
            showAnnouncement('MISS!');
            pucks.splice(index, 1);
            updateUI();
        }
        
        function updateParticles(dt) {
            particlePool.forEach(p => {
                if (!p.active) return;
                
                p.x += p.vx * dt * 60;
                p.y += p.vy * dt * 60;
                p.z += p.vz * dt * 60;
                p.vy += 20 * dt;
                p.life -= 1.5 * dt;
                
                if (p.life <= 0) {
                    p.active = false;
                }
            });
        }
        
        function showAnnouncement(text, isGoal = false) {
            announcementEl.textContent = text;
            announcementEl.classList.remove('show', 'goal');
            
            if (isGoal || text === 'GOAL!!!') {
                announcementEl.classList.add('goal');
            } else {
                announcementEl.classList.add('show');
            }
            
            setTimeout(() => {
                announcementEl.classList.remove('show', 'goal');
            }, isGoal ? 2000 : 1500);
        }
        
        function updateUI() {
            scoreEl.textContent = score;
            shotsEl.textContent = shots;
            savesEl.textContent = saves;
        }
        
        function drawBackground() {
            if (backgroundRendered) return;
            
            bgCtx.clearRect(0, 0, bgCanvas.width, bgCanvas.height);
            
            // Dark arena background
            const gradient = bgCtx.createLinearGradient(0, 0, 0, bgCanvas.height);
            gradient.addColorStop(0, '#0a0a1e');
            gradient.addColorStop(0.3, '#1a1a2e');
            gradient.addColorStop(1, '#0a0a1e');
            bgCtx.fillStyle = gradient;
            bgCtx.fillRect(0, 0, bgCanvas.width, bgCanvas.height);
            
            // Draw crowd/stands
            bgCtx.fillStyle = '#222';
            for (let y = 0; y < bgCanvas.height * 0.3; y += 20) {
                for (let x = 0; x < bgCanvas.width; x += 40) {
                    const offset = (y / 20) % 2 === 0 ? 0 : 20;
                    bgCtx.fillRect(x + offset, y, 35, 15);
                }
            }
            
            // Ice surface with perspective
            const iceGradient = bgCtx.createLinearGradient(0, bgCanvas.height / 3, 0, bgCanvas.height);
            iceGradient.addColorStop(0, '#e6f2ff');
            iceGradient.addColorStop(0.5, '#d0e4f7');
            iceGradient.addColorStop(1, '#b8d4e8');
            
            bgCtx.fillStyle = iceGradient;
            bgCtx.beginPath();
            bgCtx.moveTo(0, bgCanvas.height / 3);
            bgCtx.lineTo(bgCanvas.width, bgCanvas.height / 3);
            bgCtx.lineTo(bgCanvas.width, bgCanvas.height);
            bgCtx.lineTo(0, bgCanvas.height);
            bgCtx.closePath();
            bgCtx.fill();
            
            // Ice markings and textures
            bgCtx.strokeStyle = 'rgba(200, 220, 240, 0.3)';
            bgCtx.lineWidth = 1;
            for (let i = 0; i < 30; i++) {
                const y = bgCanvas.height / 3 + (bgCanvas.height * 2/3) * (i / 30);
                bgCtx.beginPath();
                bgCtx.moveTo(0, y);
                bgCtx.lineTo(bgCanvas.width, y);
                bgCtx.stroke();
            }
            
            // Draw rink lines
            bgCtx.strokeStyle = '#ff0000';
            bgCtx.lineWidth = 4;
            
            // Goal line
            const goalLineNear = project3D(-150, 0, NET_DISTANCE - 50);
            const goalLineFar = project3D(150, 0, NET_DISTANCE - 50);
            bgCtx.beginPath();
            bgCtx.moveTo(goalLineNear.x, goalLineNear.y);
            bgCtx.lineTo(goalLineFar.x, goalLineNear.y);
            bgCtx.stroke();
            
            // Blue line
            const blueLineNear = project3D(-200, 0, 150);
            const blueLineFar = project3D(200, 0, 150);
            bgCtx.strokeStyle = '#0066ff';
            bgCtx.lineWidth = 6;
            bgCtx.beginPath();
            bgCtx.moveTo(blueLineNear.x, blueLineNear.y);
            bgCtx.lineTo(blueLineFar.x, blueLineNear.y);
            bgCtx.stroke();
            
            // Face-off circle
            const circleCenter = project3D(0, 0, 200);
            bgCtx.strokeStyle = '#ff0000';
            bgCtx.lineWidth = 3;
            bgCtx.beginPath();
            bgCtx.arc(circleCenter.x, circleCenter.y, 50 * circleCenter.scale, 0, Math.PI * 2);
            bgCtx.stroke();
            
            // Draw boards
            bgCtx.fillStyle = '#333';
            bgCtx.fillRect(0, bgCanvas.height / 3 - 40, bgCanvas.width, 40);
            
            // Board ads
            bgCtx.fillStyle = '#fff';
            bgCtx.font = 'bold 20px Arial';
            bgCtx.fillText('RETRO HOCKEY', bgCanvas.width / 2 - 70, bgCanvas.height / 3 - 15);
            
            // Draw net
            drawNet(bgCtx);
            
            backgroundRendered = true;
        }
        
        function drawNet(context) {
            const netWidth = 200;
            const netHeight = 100;
            const netDepth = 60;
            const netTop = NET_Y_OFFSET - 40;
            
            // Net back
            context.fillStyle = 'rgba(255, 255, 255, 0.9)';
            const topLeft = project3D(-netWidth/2, netTop, NET_DISTANCE + netDepth);
            const topRight = project3D(netWidth/2, netTop, NET_DISTANCE + netDepth);
            const bottomLeft = project3D(-netWidth/2, netTop + netHeight, NET_DISTANCE + netDepth);
            const bottomRight = project3D(netWidth/2, netTop + netHeight, NET_DISTANCE + netDepth);
            
            context.beginPath();
            context.moveTo(topLeft.x, topLeft.y);
            context.lineTo(topRight.x, topRight.y);
            context.lineTo(bottomRight.x, bottomRight.y);
            context.lineTo(bottomLeft.x, bottomLeft.y);
            context.closePath();
            context.fill();
            
            // Net mesh pattern
            context.strokeStyle = 'rgba(200, 200, 200, 0.8)';
            context.lineWidth = 1;
            
            // Draw mesh grid
            for (let i = 0; i <= 10; i++) {
                for (let j = 0; j <= 5; j++) {
                    const x = -netWidth/2 + (i * netWidth/10);
                    const y = netTop + (j * netHeight/5);
                    const pos = project3D(x, y, NET_DISTANCE + netDepth);
                    
                    if (i < 10) {
                        const nextPos = project3D(x + netWidth/10, y, NET_DISTANCE + netDepth);
                        context.beginPath();
                        context.moveTo(pos.x, pos.y);
                        context.lineTo(nextPos.x, nextPos.y);
                        context.stroke();
                    }
                    
                    if (j < 5) {
                        const nextPos = project3D(x, y + netHeight/5, NET_DISTANCE + netDepth);
                        context.beginPath();
                        context.moveTo(pos.x, pos.y);
                        context.lineTo(nextPos.x, nextPos.y);
                        context.stroke();
                    }
                }
            }
            
            // Net sides
            context.fillStyle = 'rgba(255, 255, 255, 0.5)';
            
            // Left side
            const leftFront = project3D(-netWidth/2, netTop, NET_DISTANCE);
            const leftBack = project3D(-netWidth/2, netTop, NET_DISTANCE + netDepth);
            const leftBottomFront = project3D(-netWidth/2, netTop + netHeight, NET_DISTANCE);
            const leftBottomBack = project3D(-netWidth/2, netTop + netHeight, NET_DISTANCE + netDepth);
            
            context.beginPath();
            context.moveTo(leftFront.x, leftFront.y);
            context.lineTo(leftBack.x, leftBack.y);
            context.lineTo(leftBottomBack.x, leftBottomBack.y);
            context.lineTo(leftBottomFront.x, leftBottomFront.y);
            context.closePath();
            context.fill();
            
            // Right side
            const rightFront = project3D(netWidth/2, netTop, NET_DISTANCE);
            const rightBack = project3D(netWidth/2, netTop, NET_DISTANCE + netDepth);
            const rightBottomFront = project3D(netWidth/2, netTop + netHeight, NET_DISTANCE);
            const rightBottomBack = project3D(netWidth/2, netTop + netHeight, NET_DISTANCE + netDepth);
            
            context.beginPath();
            context.moveTo(rightFront.x, rightFront.y);
            context.lineTo(rightBack.x, rightBack.y);
            context.lineTo(rightBottomBack.x, rightBottomBack.y);
            context.lineTo(rightBottomFront.x, rightBottomFront.y);
            context.closePath();
            context.fill();
            
            // Posts
            context.fillStyle = '#ff0000';
            context.strokeStyle = '#aa0000';
            context.lineWidth = 4;
            
            // Left post
            const leftPostTop = project3D(-netWidth/2, netTop, NET_DISTANCE);
            const leftPostBottom = project3D(-netWidth/2, netTop + netHeight, NET_DISTANCE);
            
            context.beginPath();
            context.moveTo(leftPostTop.x - 3, leftPostTop.y);
            context.lineTo(leftPostTop.x + 3, leftPostTop.y);
            context.lineTo(leftPostBottom.x + 3, leftPostBottom.y);
            context.lineTo(leftPostBottom.x - 3, leftPostBottom.y);
            context.closePath();
            context.fill();
            context.stroke();
            
            // Right post
            const rightPostTop = project3D(netWidth/2, netTop, NET_DISTANCE);
            const rightPostBottom = project3D(netWidth/2, netTop + netHeight, NET_DISTANCE);
            
            context.beginPath();
            context.moveTo(rightPostTop.x - 3, rightPostTop.y);
            context.lineTo(rightPostTop.x + 3, rightPostTop.y);
            context.lineTo(rightPostBottom.x + 3, rightPostBottom.y);
            context.lineTo(rightPostBottom.x - 3, rightPostBottom.y);
            context.closePath();
            context.fill();
            context.stroke();
            
            // Crossbar
            context.beginPath();
            context.moveTo(leftPostTop.x, leftPostTop.y - 3);
            context.lineTo(rightPostTop.x, rightPostTop.y - 3);
            context.lineTo(rightPostTop.x, rightPostTop.y + 3);
            context.lineTo(leftPostTop.x, leftPostTop.y + 3);
            context.closePath();
            context.fill();
            context.stroke();
        }
        
        function drawGoalieSprite() {
            if (gameMode === 'practice') return;
            
            const pos = project3D(goalie.x, goalie.y, goalie.z);
            const size = 100 * pos.scale;
            
            // Shadow
            ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            ctx.beginPath();
            ctx.ellipse(pos.x, pos.y + size/2, size * 0.7, size * 0.2, 0, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.save();
            ctx.translate(pos.x, pos.y);
            
            // Subtle idle animation - slight sway
            const idleSway = Math.sin(goalie.animationFrame * 0.05) * 2;
            ctx.translate(idleSway, 0);
            
            // Draw based on stance
            if (goalie.stance === 'butterfly') {
                // Butterfly save - wide stance
                // Body
                ctx.fillStyle = '#1a1a80';
                ctx.fillRect(-size*0.4, -size*0.5, size*0.8, size*0.7);
                
                // Pads spread wide
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(-size*0.9, 0, size*0.8, size*0.3);
                ctx.fillRect(size*0.1, 0, size*0.8, size*0.3);
                
                // Pad straps
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 2;
                ctx.strokeRect(-size*0.9, 0, size*0.8, size*0.3);
                ctx.strokeRect(size*0.1, 0, size*0.8, size*0.3);
                
            } else {
                // Standing goalie
                // Body
                ctx.fillStyle = '#1a1a80';
                ctx.fillRect(-size*0.35, -size*0.5, size*0.7, size*0.9);
                
                // Jersey number
                ctx.fillStyle = '#ffffff';
                ctx.font = `bold ${size*0.3}px Arial`;
                ctx.textAlign = 'center';
                ctx.fillText('31', 0, 0);
                
                // Pads
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(-size*0.3, size*0.2, size*0.25, size*0.5);
                ctx.fillRect(size*0.05, size*0.2, size*0.25, size*0.5);
                
                // Pad details
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 2;
                for (let i = 0; i < 3; i++) {
                    ctx.strokeRect(-size*0.3, size*0.2 + i*size*0.15, size*0.25, size*0.1);
                    ctx.strokeRect(size*0.05, size*0.2 + i*size*0.15, size*0.25, size*0.1);
                }
            }
            
            // Glove - positioned based on stance
            ctx.fillStyle = '#8B4513';
            ctx.strokeStyle = '#654321';
            ctx.lineWidth = 2;
            const gloveY = goalie.stance === 'glove' ? -size*0.4 : -size*0.2;
            ctx.beginPath();
            ctx.arc(-size*0.5, gloveY, size*0.22, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();
            
            // Glove webbing
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 1;
            for (let i = 0; i < 4; i++) {
                ctx.beginPath();
                ctx.arc(-size*0.5, gloveY, size*0.15 - i*3, 0, Math.PI * 2);
                ctx.stroke();
            }
            
            // Blocker
            const blockerY = goalie.stance === 'blocker' ? -size*0.4 : -size*0.2;
            ctx.fillStyle = '#8B4513';
            ctx.fillRect(size*0.3, blockerY, size*0.3, size*0.4);
            ctx.strokeStyle = '#654321';
            ctx.lineWidth = 2;
            ctx.strokeRect(size*0.3, blockerY, size*0.3, size*0.4);
            
            // Mask
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(-size*0.2, -size*0.7, size*0.4, size*0.3);
            
            // Mask cage detail
            ctx.strokeStyle = '#000000';
            ctx.lineWidth = 1;
            // Horizontal bars
            for (let i = 0; i < 4; i++) {
                ctx.beginPath();
                ctx.moveTo(-size*0.15, -size*0.65 + i*size*0.06);
                ctx.lineTo(size*0.15, -size*0.65 + i*size*0.06);
                ctx.stroke();
            }
            // Vertical bars
            for (let i = 0; i < 5; i++) {
                ctx.beginPath();
                ctx.moveTo(-size*0.15 + i*size*0.075, -size*0.7);
                ctx.lineTo(-size*0.15 + i*size*0.075, -size*0.4);
                ctx.stroke();
            }
            
            // Team logo on mask
            ctx.fillStyle = '#ff0000';
            ctx.beginPath();
            ctx.arc(0, -size*0.6, size*0.08, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.restore();
            
            // Save animation
            if (goalie.saveAnimation > 0) {
                ctx.strokeStyle = `rgba(255, 255, 0, ${goalie.saveAnimation * 0.8})`;
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(pos.x, pos.y, size * 1.5, 0, Math.PI * 2);
                ctx.stroke();
                
                // Lightning effect
                ctx.strokeStyle = `rgba(255, 255, 0, ${goalie.saveAnimation})`;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(pos.x - size, pos.y - size);
                ctx.lineTo(pos.x - size*0.3, pos.y);
                ctx.lineTo(pos.x + size*0.3, pos.y - size*0.5);
                ctx.lineTo(pos.x + size, pos.y + size*0.5);
                ctx.stroke();
            }
        }
        
        function drawPlayerSprite() {
            const pos = project3D(player.x, player.y, player.z);
            const size = 80 * pos.scale;
            
            ctx.save();
            ctx.translate(pos.x, pos.y - canvas.height/2 + 100);
            
            // Player shadow
            ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            ctx.beginPath();
            ctx.ellipse(0, size*0.8, size * 0.5, size * 0.15, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // Player body
            ctx.fillStyle = '#ff0000';
            ctx.fillRect(-size*0.3, -size*0.4, size*0.6, size*0.7);
            
            // Jersey details
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(-size*0.3, -size*0.1, size*0.6, size*0.1);
            ctx.font = `bold ${size*0.25}px Arial`;
            ctx.textAlign = 'center';
            ctx.fillText('99', 0, size*0.15);
            
            // Pants
            ctx.fillStyle = '#000080';
            ctx.fillRect(-size*0.25, size*0.3, size*0.5, size*0.3);
            
            // Skates
            ctx.fillStyle = '#333';
            ctx.fillRect(-size*0.2, size*0.6, size*0.15, size*0.2);
            ctx.fillRect(size*0.05, size*0.6, size*0.15, size*0.2);
            
            // Stick
            ctx.strokeStyle = '#8B4513';
            ctx.lineWidth = size*0.08;
            
            if (player.shooting) {
                // Wind-up position
                ctx.beginPath();
                ctx.moveTo(size*0.3, -size*0.2);
                ctx.lineTo(size*0.6, -size*0.4);
                ctx.stroke();
                
                // Blade
                ctx.fillStyle = '#000000';
                ctx.save();
                ctx.translate(size*0.6, -size*0.4);
                ctx.rotate(-Math.PI/4);
                ctx.fillRect(-size*0.05, 0, size*0.1, size*0.15);
                ctx.restore();
            } else {
                // Normal position
                ctx.beginPath();
                ctx.moveTo(size*0.3, size*0.1);
                ctx.lineTo(size*0.5, size*0.5);
                ctx.stroke();
                
                // Blade
                ctx.fillStyle = '#000000';
                ctx.fillRect(size*0.45, size*0.5, size*0.15, size*0.08);
            }
            
            // Helmet
            ctx.fillStyle = '#ff0000';
            ctx.beginPath();
            ctx.arc(0, -size*0.6, size*0.25, -Math.PI, 0);
            ctx.fill();
            
            // Visor
            ctx.strokeStyle = 'rgba(200, 200, 255, 0.5)';
            ctx.lineWidth = size*0.05;
            ctx.beginPath();
            ctx.arc(0, -size*0.6, size*0.2, -Math.PI*0.8, -Math.PI*0.2);
            ctx.stroke();
            
            ctx.restore();
        }
        
        function drawPuck(puck) {
            const pos = project3D(puck.x, puck.y, puck.z);
            const size = puck.size * pos.scale;
            
            // Draw motion trail
            if (puck.trail.length > 1) {
                ctx.strokeStyle = 'rgba(0, 0, 0, 0.2)';
                ctx.lineWidth = size * 0.8;
                ctx.lineCap = 'round';
                ctx.beginPath();
                
                for (let i = 0; i < puck.trail.length; i++) {
                    const trailPos = project3D(puck.trail[i].x, puck.trail[i].y, puck.trail[i].z);
                    const alpha = i / puck.trail.length * 0.3;
                    ctx.strokeStyle = `rgba(0, 0, 0, ${alpha})`;
                    
                    if (i === 0) {
                        ctx.moveTo(trailPos.x, trailPos.y);
                    } else {
                        ctx.lineTo(trailPos.x, trailPos.y);
                    }
                }
                ctx.stroke();
            }
            
            // Puck shadow on ice
            const shadowY = 50;
            const shadowPos = project3D(puck.x, shadowY, puck.z);
            const shadowSize = size * 1.5 * (1 - (puck.y - shadowY) / 200);
            ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            ctx.beginPath();
            ctx.ellipse(shadowPos.x, shadowPos.y, shadowSize, shadowSize * 0.3, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // Draw puck
            ctx.save();
            ctx.translate(pos.x, pos.y);
            ctx.rotate(puck.rotation);
            
            // Puck body with 3D effect
            ctx.fillStyle = '#000000';
            ctx.beginPath();
            ctx.arc(0, 0, size, 0, Math.PI * 2);
            ctx.fill();
            
            // Top surface highlight
            ctx.fillStyle = '#222';
            ctx.beginPath();
            ctx.arc(0, -size*0.1, size*0.9, 0, Math.PI * 2);
            ctx.fill();
            
            // Logo/detail
            ctx.strokeStyle = '#444';
            ctx.lineWidth = size * 0.15;
            ctx.beginPath();
            ctx.arc(0, 0, size * 0.6, 0, Math.PI * 2);
            ctx.stroke();
            
            // Spinning effect
            if (Math.sin(puck.spin) > 0) {
                ctx.strokeStyle = '#666';
                ctx.lineWidth = size * 0.1;
                ctx.beginPath();
                ctx.moveTo(-size, 0);
                ctx.lineTo(size, 0);
                ctx.stroke();
            }
            
            ctx.restore();
        }
        
        function drawRebound(rebound) {
            const pos = project3D(rebound.x, rebound.y, rebound.z);
            const size = rebound.size * pos.scale;
            
            ctx.save();
            ctx.translate(pos.x, pos.y);
            ctx.rotate(rebound.spin);
            
            ctx.fillStyle = '#000000';
            ctx.beginPath();
            ctx.arc(0, 0, size, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.strokeStyle = '#444';
            ctx.lineWidth = size * 0.2;
            ctx.beginPath();
            ctx.arc(0, 0, size * 0.7, 0, Math.PI * 2);
            ctx.stroke();
            
            ctx.restore();
        }
        
        function drawParticles() {
            particlePool.forEach(p => {
                if (!p.active) return;
                
                const pos = project3D(p.x, p.y, p.z);
                const size = p.size * pos.scale * p.life;
                
                ctx.save();
                
                if (p.type === 'ice') {
                    // Ice shavings
                    ctx.fillStyle = `rgba(255, 255, 255, ${p.life * 0.8})`;
                    ctx.fillRect(pos.x - size/2, pos.y - size/2, size, size);
                } else if (p.type === 'spark') {
                    // Sparks from post hit
                    ctx.fillStyle = p.color || `rgba(255, 200, 0, ${p.life})`;
                    ctx.beginPath();
                    ctx.moveTo(pos.x, pos.y - size);
                    ctx.lineTo(pos.x + size*0.5, pos.y + size*0.5);
                    ctx.lineTo(pos.x - size*0.5, pos.y + size*0.5);
                    ctx.closePath();
                    ctx.fill();
                } else if (p.type === 'celebration') {
                    // Confetti
                    ctx.fillStyle = p.color || `rgba(255, 255, 255, ${p.life})`;
                    ctx.save();
                    ctx.translate(pos.x, pos.y);
                    ctx.rotate(p.life * Math.PI * 4);
                    ctx.fillRect(-size/2, -size/2, size, size/2);
                    ctx.restore();
                } else {
                    // Default circular particle
                    ctx.fillStyle = p.color || `rgba(255, 255, 255, ${p.life})`;
                    ctx.beginPath();
                    ctx.arc(pos.x, pos.y, size, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                ctx.restore();
            });
        }
        
        function drawStick() {
            if (!isSwiping && pucks.length === 0 && !player.shooting) {
                const centerX = canvas.width / 2;
                const centerY = canvas.height - 150;
                const angle = Math.atan2(mouseY - centerY, mouseX - centerX);
                const stickLength = 100;
                const stickX = centerX + Math.cos(angle) * stickLength;
                const stickY = centerY + Math.sin(angle) * stickLength;
                
                // Stick shaft with wood texture
                ctx.strokeStyle = '#8B4513';
                ctx.lineWidth = 8;
                ctx.lineCap = 'round';
                ctx.beginPath();
                ctx.moveTo(centerX, centerY);
                ctx.lineTo(stickX, stickY);
                ctx.stroke();
                
                // Tape on shaft
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 6;
                ctx.beginPath();
                ctx.moveTo(centerX + Math.cos(angle) * 20, centerY + Math.sin(angle) * 20);
                ctx.lineTo(centerX + Math.cos(angle) * 40, centerY + Math.sin(angle) * 40);
                ctx.stroke();
                
                // Blade
                ctx.fillStyle = '#000000';
                ctx.save();
                ctx.translate(stickX, stickY);
                ctx.rotate(angle + Math.PI / 2);
                
                // Blade shape
                ctx.beginPath();
                ctx.moveTo(-5, 0);
                ctx.lineTo(-3, 30);
                ctx.lineTo(3, 30);
                ctx.lineTo(5, 0);
                ctx.closePath();
                ctx.fill();
                
                // Blade tape pattern
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 1;
                for (let i = 0; i < 4; i++) {
                    ctx.beginPath();
                    ctx.moveTo(-3, 5 + i*6);
                    ctx.lineTo(3, 5 + i*6);
                    ctx.stroke();
                }
                
                ctx.restore();
            }
        }
        
        function drawAimPrediction() {
            if (!isSwiping || !swipePreview) return;
            
            const dx = swipePreview.currentX - swipePreview.startX;
            const dy = swipePreview.currentY - swipePreview.startY;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            if (distance < 10) return; // Don't show for tiny movements
            
            // Calculate predicted shot angle
            const angle = Math.atan2(-dy, dx);
            const power = Math.min(distance / 200, 1);
            
            // Start position (player)
            const startPos = project3D(0, 50, 0);
            
            // Calculate end position based on angle and power
            const velocity = 20 + power * 15; // Base velocity for wrist shot
            const predictedX = Math.cos(angle) * velocity * 10;
            const predictedZ = NET_DISTANCE;
            const predictedY = NET_Y_OFFSET + Math.sin(angle) * velocity * 3;
            
            const endPos = project3D(predictedX, predictedY, predictedZ);
            
            // Draw prediction line
            ctx.save();
            ctx.strokeStyle = `rgba(0, 255, 255, ${0.3 + power * 0.4})`;
            ctx.lineWidth = 2 + power * 3;
            ctx.setLineDash([10, 5]);
            ctx.lineCap = 'round';
            
            ctx.beginPath();
            ctx.moveTo(startPos.x, startPos.y);
            
            // Add curve to show arc
            const midZ = predictedZ / 2;
            const midY = 50 + (predictedY - 50) * 0.5 - 30; // Arc height
            const midPos = project3D(predictedX * 0.5, midY, midZ);
            
            ctx.quadraticCurveTo(midPos.x, midPos.y, endPos.x, endPos.y);
            ctx.stroke();
            
            // Draw impact point
            ctx.fillStyle = `rgba(255, 255, 0, ${0.5 + power * 0.5})`;
            ctx.beginPath();
            ctx.arc(endPos.x, endPos.y, 5 + power * 10, 0, Math.PI * 2);
            ctx.fill();
            
            // Show power percentage
            ctx.fillStyle = '#ffffff';
            ctx.font = 'bold 16px "Press Start 2P"';
            ctx.textAlign = 'center';
            ctx.fillText(`${Math.floor(power * 100)}%`, startPos.x, startPos.y - 30);
            
            ctx.restore();
        }
        
        function drawRinkDetails() {
            // Draw face-off dots
            ctx.fillStyle = '#ff0000';
            const dotPositions = [
                { x: -150, z: 200 },
                { x: 150, z: 200 },
                { x: -150, z: NET_DISTANCE - 100 },
                { x: 150, z: NET_DISTANCE - 100 }
            ];
            
            dotPositions.forEach(dot => {
                const pos = project3D(dot.x, 0, dot.z);
                ctx.beginPath();
                ctx.arc(pos.x, pos.y, 5 * pos.scale, 0, Math.PI * 2);
                ctx.fill();
            });
            
            // Crease
            const creaseRadius = 60;
            const creaseCenter = project3D(0, 0, NET_DISTANCE - 30);
            ctx.strokeStyle = '#ff0000';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(creaseCenter.x, creaseCenter.y, creaseRadius * creaseCenter.scale, 0, Math.PI);
            ctx.stroke();
            
            // Crease fill
            ctx.fillStyle = 'rgba(135, 206, 250, 0.3)';
            ctx.fill();
        }
        
        function gameLoop(currentTime) {
            if (!gameActive) return;
            
            deltaTime = Math.min((currentTime - lastTime) / 1000, 0.1);
            lastTime = currentTime;
            
            // Clear game canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw static background
            drawBackground();
            
            // Update animations
            animationFrame += deltaTime * 60;
            
            // Update game objects
            updateGoalie(deltaTime);
            updatePlayer(deltaTime);
            updatePucks(deltaTime);
            updateParticles(deltaTime);
            updateScreenShake(deltaTime);
            
            // Apply screen shake
            ctx.save();
            ctx.translate(screenShakeX, screenShakeY);
            
            // Update charge power
            if (isCharging) {
                shotPower = Math.min(shotPower + 0.9 * deltaTime, 1);
                powerFillEl.style.height = (shotPower * 100) + '%';
                
                // Add charging particles
                if (Math.random() < 0.3) {
                    const particle = getParticle();
                    if (particle) {
                        const angle = Math.random() * Math.PI * 2;
                        const dist = 20 + Math.random() * 30;
                        particle.x = Math.cos(angle) * dist;
                        particle.y = 50 + Math.sin(angle) * dist;
                        particle.z = 0;
                        particle.vx = -particle.x * 0.1;
                        particle.vy = -particle.y * 0.1;
                        particle.vz = 0;
                        particle.life = 0.5;
                        particle.size = 2;
                        particle.color = shotPower > 0.7 ? '#ff0000' : shotPower > 0.4 ? '#ffff00' : '#00ff00';
                        particle.type = 'charge';
                    }
                }
            }
            
            // Draw game elements in order
            drawRinkDetails();
            rebounds.forEach(rebound => drawRebound(rebound));
            drawParticles();
            drawGoalieSprite();
            pucks.forEach(puck => drawPuck(puck));
            drawPlayerSprite();
            drawStick();
            drawAimPrediction();
            
            // Restore canvas transform
            ctx.restore();
            
            // Check game over conditions
            if (gameMode === 'classic' && shots >= 5 && pucks.length === 0) {
                endGame();
                return;
            }
            
            requestAnimationFrame(gameLoop);
        }
        
        function endGame() {
            gameActive = false;
            
            const accuracy = shots > 0 ? Math.round(((shots - saves) / shots) * 100) : 0;
            const goals = shots - saves;
            
            document.getElementById('finalScore').textContent = score;
            document.getElementById('finalAccuracy').textContent = accuracy + '%';
            document.getElementById('finalGoals').textContent = goals + '/' + shots;
            
            setTimeout(() => {
                gameOverScreenEl.style.display = 'block';
            }, 1500);
        }
        
        function playAgain() {
            gameOverScreenEl.style.display = 'none';
            startGame(gameMode);
        }
        
        function returnToMenu() {
            gameActive = false;
            
            score = 0;
            shots = 0;
            saves = 0;
            shotPower = 0;
            isCharging = false;
            pucks = [];
            rebounds = [];
            particlePool.forEach(p => p.active = false);
            
            goalie.x = 0;
            goalie.y = NET_Y_OFFSET;
            goalie.stance = 'ready';
            goalie.saveAnimation = 0;
            goalie.stanceTimer = 0;
            
            player.shooting = false;
            player.shootTimer = 0;
            
            powerFillEl.style.height = '0%';
            crosshairEl.classList.remove('show');
            updateUI();
            
            announcementEl.classList.remove('show');
            
            powerMeterContainerEl.style.display = 'none';
            shotTypeEl.style.display = 'none';
            controlsEl.style.display = 'none';
            shotSelectorEl.style.display = 'none';
            
            startScreenEl.style.display = 'flex';
            homeBtnEl.style.display = 'none';
            gameOverScreenEl.style.display = 'none';
            
            if (canVibrate) navigator.vibrate(10);
        }
        
        // Initialize
        updateUI();
    </script>
</body>
</html>
